{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.unescapeValue = unescapeValue;\nexports[\"default\"] = void 0;\n\nvar _cssesc = _interopRequireDefault(require(\"cssesc\"));\n\nvar _unesc = _interopRequireDefault(require(\"../util/unesc\"));\n\nvar _namespace = _interopRequireDefault(require(\"./namespace\"));\n\nvar _types = require(\"./types\");\n\nvar _CSSESC_QUOTE_OPTIONS;\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nvar deprecate = require(\"util-deprecate\");\n\nvar WRAPPED_IN_QUOTES = /^('|\")([^]*)\\1$/;\nvar warnOfDeprecatedValueAssignment = deprecate(function () {}, \"Assigning an attribute a value containing characters that might need to be escaped is deprecated. \" + \"Call attribute.setValue() instead.\");\nvar warnOfDeprecatedQuotedAssignment = deprecate(function () {}, \"Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.\");\nvar warnOfDeprecatedConstructor = deprecate(function () {}, \"Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.\");\n\nfunction unescapeValue(value) {\n  var deprecatedUsage = false;\n  var quoteMark = null;\n  var unescaped = value;\n  var m = unescaped.match(WRAPPED_IN_QUOTES);\n\n  if (m) {\n    quoteMark = m[1];\n    unescaped = m[2];\n  }\n\n  unescaped = (0, _unesc[\"default\"])(unescaped);\n\n  if (unescaped !== value) {\n    deprecatedUsage = true;\n  }\n\n  return {\n    deprecatedUsage: deprecatedUsage,\n    unescaped: unescaped,\n    quoteMark: quoteMark\n  };\n}\n\nfunction handleDeprecatedContructorOpts(opts) {\n  if (opts.quoteMark !== undefined) {\n    return opts;\n  }\n\n  if (opts.value === undefined) {\n    return opts;\n  }\n\n  warnOfDeprecatedConstructor();\n\n  var _unescapeValue = unescapeValue(opts.value),\n      quoteMark = _unescapeValue.quoteMark,\n      unescaped = _unescapeValue.unescaped;\n\n  if (!opts.raws) {\n    opts.raws = {};\n  }\n\n  if (opts.raws.value === undefined) {\n    opts.raws.value = opts.value;\n  }\n\n  opts.value = unescaped;\n  opts.quoteMark = quoteMark;\n  return opts;\n}\n\nvar Attribute = /*#__PURE__*/function (_Namespace) {\n  _inheritsLoose(Attribute, _Namespace);\n\n  function Attribute(opts) {\n    var _this;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;\n    _this.type = _types.ATTRIBUTE;\n    _this.raws = _this.raws || {};\n    Object.defineProperty(_this.raws, 'unquoted', {\n      get: deprecate(function () {\n        return _this.value;\n      }, \"attr.raws.unquoted is deprecated. Call attr.value instead.\"),\n      set: deprecate(function () {\n        return _this.value;\n      }, \"Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.\")\n    });\n    _this._constructed = true;\n    return _this;\n  }\n  /**\n   * Returns the Attribute's value quoted such that it would be legal to use\n   * in the value of a css file. The original value's quotation setting\n   * used for stringification is left unchanged. See `setValue(value, options)`\n   * if you want to control the quote settings of a new value for the attribute.\n   *\n   * You can also change the quotation used for the current value by setting quoteMark.\n   *\n   * Options:\n   *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\n   *     option is not set, the original value for quoteMark will be used. If\n   *     indeterminate, a double quote is used. The legal values are:\n   *     * `null` - the value will be unquoted and characters will be escaped as necessary.\n   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\n   *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\n   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\n   *     over the quoteMark option value.\n   *   * smart {boolean} - if true, will select a quote mark based on the value\n   *     and the other options specified here. See the `smartQuoteMark()`\n   *     method.\n   **/\n\n\n  var _proto = Attribute.prototype;\n\n  _proto.getQuotedValue = function getQuotedValue(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var quoteMark = this._determineQuoteMark(options);\n\n    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\n    var escaped = (0, _cssesc[\"default\"])(this._value, cssescopts);\n    return escaped;\n  };\n\n  _proto._determineQuoteMark = function _determineQuoteMark(options) {\n    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\n  }\n  /**\n   * Set the unescaped value with the specified quotation options. The value\n   * provided must not include any wrapping quote marks -- those quotes will\n   * be interpreted as part of the value and escaped accordingly.\n   */\n  ;\n\n  _proto.setValue = function setValue(value, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this._value = value;\n    this._quoteMark = this._determineQuoteMark(options);\n\n    this._syncRawValue();\n  }\n  /**\n   * Intelligently select a quoteMark value based on the value's contents. If\n   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\n   * mark will be picked that minimizes the number of escapes.\n   *\n   * If there's no clear winner, the quote mark from these options is used,\n   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\n   * true). If the quoteMark is unspecified, a double quote is used.\n   *\n   * @param options This takes the quoteMark and preferCurrentQuoteMark options\n   * from the quoteValue method.\n   */\n  ;\n\n  _proto.smartQuoteMark = function smartQuoteMark(options) {\n    var v = this.value;\n    var numSingleQuotes = v.replace(/[^']/g, '').length;\n    var numDoubleQuotes = v.replace(/[^\"]/g, '').length;\n\n    if (numSingleQuotes + numDoubleQuotes === 0) {\n      var escaped = (0, _cssesc[\"default\"])(v, {\n        isIdentifier: true\n      });\n\n      if (escaped === v) {\n        return Attribute.NO_QUOTE;\n      } else {\n        var pref = this.preferredQuoteMark(options);\n\n        if (pref === Attribute.NO_QUOTE) {\n          // pick a quote mark that isn't none and see if it's smaller\n          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\n          var opts = CSSESC_QUOTE_OPTIONS[quote];\n          var quoteValue = (0, _cssesc[\"default\"])(v, opts);\n\n          if (quoteValue.length < escaped.length) {\n            return quote;\n          }\n        }\n\n        return pref;\n      }\n    } else if (numDoubleQuotes === numSingleQuotes) {\n      return this.preferredQuoteMark(options);\n    } else if (numDoubleQuotes < numSingleQuotes) {\n      return Attribute.DOUBLE_QUOTE;\n    } else {\n      return Attribute.SINGLE_QUOTE;\n    }\n  }\n  /**\n   * Selects the preferred quote mark based on the options and the current quote mark value.\n   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\n   * instead.\n   */\n  ;\n\n  _proto.preferredQuoteMark = function preferredQuoteMark(options) {\n    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;\n\n    if (quoteMark === undefined) {\n      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;\n    }\n\n    if (quoteMark === undefined) {\n      quoteMark = Attribute.DOUBLE_QUOTE;\n    }\n\n    return quoteMark;\n  };\n\n  _proto._syncRawValue = function _syncRawValue() {\n    var rawValue = (0, _cssesc[\"default\"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\n\n    if (rawValue === this._value) {\n      if (this.raws) {\n        delete this.raws.value;\n      }\n    } else {\n      this.raws.value = rawValue;\n    }\n  };\n\n  _proto._handleEscapes = function _handleEscapes(prop, value) {\n    if (this._constructed) {\n      var escaped = (0, _cssesc[\"default\"])(value, {\n        isIdentifier: true\n      });\n\n      if (escaped !== value) {\n        this.raws[prop] = escaped;\n      } else {\n        delete this.raws[prop];\n      }\n    }\n  };\n\n  _proto._spacesFor = function _spacesFor(name) {\n    var attrSpaces = {\n      before: '',\n      after: ''\n    };\n    var spaces = this.spaces[name] || {};\n    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};\n    return Object.assign(attrSpaces, spaces, rawSpaces);\n  };\n\n  _proto._stringFor = function _stringFor(name, spaceName, concat) {\n    if (spaceName === void 0) {\n      spaceName = name;\n    }\n\n    if (concat === void 0) {\n      concat = defaultAttrConcat;\n    }\n\n    var attrSpaces = this._spacesFor(spaceName);\n\n    return concat(this.stringifyProperty(name), attrSpaces);\n  }\n  /**\n   * returns the offset of the attribute part specified relative to the\n   * start of the node of the output string.\n   *\n   * * \"ns\" - alias for \"namespace\"\n   * * \"namespace\" - the namespace if it exists.\n   * * \"attribute\" - the attribute name\n   * * \"attributeNS\" - the start of the attribute or its namespace\n   * * \"operator\" - the match operator of the attribute\n   * * \"value\" - The value (string or identifier)\n   * * \"insensitive\" - the case insensitivity flag;\n   * @param part One of the possible values inside an attribute.\n   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\n   */\n  ;\n\n  _proto.offsetOf = function offsetOf(name) {\n    var count = 1;\n\n    var attributeSpaces = this._spacesFor(\"attribute\");\n\n    count += attributeSpaces.before.length;\n\n    if (name === \"namespace\" || name === \"ns\") {\n      return this.namespace ? count : -1;\n    }\n\n    if (name === \"attributeNS\") {\n      return count;\n    }\n\n    count += this.namespaceString.length;\n\n    if (this.namespace) {\n      count += 1;\n    }\n\n    if (name === \"attribute\") {\n      return count;\n    }\n\n    count += this.stringifyProperty(\"attribute\").length;\n    count += attributeSpaces.after.length;\n\n    var operatorSpaces = this._spacesFor(\"operator\");\n\n    count += operatorSpaces.before.length;\n    var operator = this.stringifyProperty(\"operator\");\n\n    if (name === \"operator\") {\n      return operator ? count : -1;\n    }\n\n    count += operator.length;\n    count += operatorSpaces.after.length;\n\n    var valueSpaces = this._spacesFor(\"value\");\n\n    count += valueSpaces.before.length;\n    var value = this.stringifyProperty(\"value\");\n\n    if (name === \"value\") {\n      return value ? count : -1;\n    }\n\n    count += value.length;\n    count += valueSpaces.after.length;\n\n    var insensitiveSpaces = this._spacesFor(\"insensitive\");\n\n    count += insensitiveSpaces.before.length;\n\n    if (name === \"insensitive\") {\n      return this.insensitive ? count : -1;\n    }\n\n    return -1;\n  };\n\n  _proto.toString = function toString() {\n    var _this2 = this;\n\n    var selector = [this.rawSpaceBefore, '['];\n    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\n\n    if (this.operator && (this.value || this.value === '')) {\n      selector.push(this._stringFor('operator'));\n      selector.push(this._stringFor('value'));\n      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {\n        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {\n          attrSpaces.before = \" \";\n        }\n\n        return defaultAttrConcat(attrValue, attrSpaces);\n      }));\n    }\n\n    selector.push(']');\n    selector.push(this.rawSpaceAfter);\n    return selector.join('');\n  };\n\n  _createClass(Attribute, [{\n    key: \"quoted\",\n    get: function get() {\n      var qm = this.quoteMark;\n      return qm === \"'\" || qm === '\"';\n    },\n    set: function set(value) {\n      warnOfDeprecatedQuotedAssignment();\n    }\n    /**\n     * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\n     * returns `null` if the value is not quoted.\n     * returns `undefined` if the quotation state is unknown (this can happen when\n     * the attribute is constructed without specifying a quote mark.)\n     */\n\n  }, {\n    key: \"quoteMark\",\n    get: function get() {\n      return this._quoteMark;\n    }\n    /**\n     * Set the quote mark to be used by this attribute's value.\n     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\n     * value is updated accordingly.\n     *\n     * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\n     */\n    ,\n    set: function set(quoteMark) {\n      if (!this._constructed) {\n        this._quoteMark = quoteMark;\n        return;\n      }\n\n      if (this._quoteMark !== quoteMark) {\n        this._quoteMark = quoteMark;\n\n        this._syncRawValue();\n      }\n    }\n  }, {\n    key: \"qualifiedAttribute\",\n    get: function get() {\n      return this.qualifiedName(this.raws.attribute || this.attribute);\n    }\n  }, {\n    key: \"insensitiveFlag\",\n    get: function get() {\n      return this.insensitive ? 'i' : '';\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    }\n    /**\n     * Before 3.0, the value had to be set to an escaped value including any wrapped\n     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\n     * is unescaped during parsing and any quote marks are removed.\n     *\n     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\n     * a deprecation warning is raised when the new value contains any characters that would\n     * require escaping (including if it contains wrapped quotes).\n     *\n     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\n     * how the new value is quoted.\n     */\n    ,\n    set: function set(v) {\n      if (this._constructed) {\n        var _unescapeValue2 = unescapeValue(v),\n            deprecatedUsage = _unescapeValue2.deprecatedUsage,\n            unescaped = _unescapeValue2.unescaped,\n            quoteMark = _unescapeValue2.quoteMark;\n\n        if (deprecatedUsage) {\n          warnOfDeprecatedValueAssignment();\n        }\n\n        if (unescaped === this._value && quoteMark === this._quoteMark) {\n          return;\n        }\n\n        this._value = unescaped;\n        this._quoteMark = quoteMark;\n\n        this._syncRawValue();\n      } else {\n        this._value = v;\n      }\n    }\n  }, {\n    key: \"attribute\",\n    get: function get() {\n      return this._attribute;\n    },\n    set: function set(name) {\n      this._handleEscapes(\"attribute\", name);\n\n      this._attribute = name;\n    }\n  }]);\n\n  return Attribute;\n}(_namespace[\"default\"]);\n\nexports[\"default\"] = Attribute;\nAttribute.NO_QUOTE = null;\nAttribute.SINGLE_QUOTE = \"'\";\nAttribute.DOUBLE_QUOTE = '\"';\nvar CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {\n  \"'\": {\n    quotes: 'single',\n    wrap: true\n  },\n  '\"': {\n    quotes: 'double',\n    wrap: true\n  }\n}, _CSSESC_QUOTE_OPTIONS[null] = {\n  isIdentifier: true\n}, _CSSESC_QUOTE_OPTIONS);\n\nfunction defaultAttrConcat(attrValue, attrSpaces) {\n  return \"\" + attrSpaces.before + attrValue + attrSpaces.after;\n}","map":{"version":3,"sources":["C:/Users/Akshat Verma/Desktop/Practice/react/react_tut/node_modules/postcss-selector-parser/dist/selectors/attribute.js"],"names":["exports","__esModule","unescapeValue","_cssesc","_interopRequireDefault","require","_unesc","_namespace","_types","_CSSESC_QUOTE_OPTIONS","obj","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","_inheritsLoose","subClass","superClass","create","constructor","_setPrototypeOf","o","p","setPrototypeOf","__proto__","deprecate","WRAPPED_IN_QUOTES","warnOfDeprecatedValueAssignment","warnOfDeprecatedQuotedAssignment","warnOfDeprecatedConstructor","value","deprecatedUsage","quoteMark","unescaped","m","match","handleDeprecatedContructorOpts","opts","undefined","_unescapeValue","raws","Attribute","_Namespace","_this","call","type","ATTRIBUTE","get","set","_constructed","_proto","getQuotedValue","options","_determineQuoteMark","cssescopts","CSSESC_QUOTE_OPTIONS","escaped","_value","smart","smartQuoteMark","preferredQuoteMark","setValue","_quoteMark","_syncRawValue","v","numSingleQuotes","replace","numDoubleQuotes","isIdentifier","NO_QUOTE","pref","quote","DOUBLE_QUOTE","quoteValue","SINGLE_QUOTE","preferCurrentQuoteMark","rawValue","_handleEscapes","prop","_spacesFor","name","attrSpaces","before","after","spaces","rawSpaces","assign","_stringFor","spaceName","concat","defaultAttrConcat","stringifyProperty","offsetOf","count","attributeSpaces","namespace","namespaceString","operatorSpaces","operator","valueSpaces","insensitiveSpaces","insensitive","toString","_this2","selector","rawSpaceBefore","push","attrValue","quoted","rawSpaceAfter","join","qm","qualifiedName","attribute","_unescapeValue2","_attribute","quotes","wrap"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAACE,aAAR,GAAwBA,aAAxB;AACAF,OAAO,CAAC,SAAD,CAAP,GAAqB,KAAK,CAA1B;;AAEA,IAAIG,OAAO,GAAGC,sBAAsB,CAACC,OAAO,CAAC,QAAD,CAAR,CAApC;;AAEA,IAAIC,MAAM,GAAGF,sBAAsB,CAACC,OAAO,CAAC,eAAD,CAAR,CAAnC;;AAEA,IAAIE,UAAU,GAAGH,sBAAsB,CAACC,OAAO,CAAC,aAAD,CAAR,CAAvC;;AAEA,IAAIG,MAAM,GAAGH,OAAO,CAAC,SAAD,CAApB;;AAEA,IAAII,qBAAJ;;AAEA,SAASL,sBAAT,CAAgCM,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACT,UAAX,GAAwBS,GAAxB,GAA8B;AAAE,eAAWA;AAAb,GAArC;AAA0D;;AAEjG,SAASC,iBAAT,CAA2BC,MAA3B,EAAmCC,KAAnC,EAA0C;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,QAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,IAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,IAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,QAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,IAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAE7T,SAASO,YAAT,CAAsBC,WAAtB,EAAmCC,UAAnC,EAA+CC,WAA/C,EAA4D;AAAE,MAAID,UAAJ,EAAgBd,iBAAiB,CAACa,WAAW,CAACG,SAAb,EAAwBF,UAAxB,CAAjB;AAAsD,MAAIC,WAAJ,EAAiBf,iBAAiB,CAACa,WAAD,EAAcE,WAAd,CAAjB;AAA6C,SAAOF,WAAP;AAAqB;;AAEvN,SAASI,cAAT,CAAwBC,QAAxB,EAAkCC,UAAlC,EAA8C;AAAED,EAAAA,QAAQ,CAACF,SAAT,GAAqBP,MAAM,CAACW,MAAP,CAAcD,UAAU,CAACH,SAAzB,CAArB;AAA0DE,EAAAA,QAAQ,CAACF,SAAT,CAAmBK,WAAnB,GAAiCH,QAAjC;;AAA2CI,EAAAA,eAAe,CAACJ,QAAD,EAAWC,UAAX,CAAf;AAAwC;;AAE7L,SAASG,eAAT,CAAyBC,CAAzB,EAA4BC,CAA5B,EAA+B;AAAEF,EAAAA,eAAe,GAAGb,MAAM,CAACgB,cAAP,IAAyB,SAASH,eAAT,CAAyBC,CAAzB,EAA4BC,CAA5B,EAA+B;AAAED,IAAAA,CAAC,CAACG,SAAF,GAAcF,CAAd;AAAiB,WAAOD,CAAP;AAAW,GAAxG;;AAA0G,SAAOD,eAAe,CAACC,CAAD,EAAIC,CAAJ,CAAtB;AAA+B;;AAE1K,IAAIG,SAAS,GAAGjC,OAAO,CAAC,gBAAD,CAAvB;;AAEA,IAAIkC,iBAAiB,GAAG,iBAAxB;AACA,IAAIC,+BAA+B,GAAGF,SAAS,CAAC,YAAY,CAAE,CAAf,EAAiB,uGAAuG,oCAAxH,CAA/C;AACA,IAAIG,gCAAgC,GAAGH,SAAS,CAAC,YAAY,CAAE,CAAf,EAAiB,0FAAjB,CAAhD;AACA,IAAII,2BAA2B,GAAGJ,SAAS,CAAC,YAAY,CAAE,CAAf,EAAiB,sIAAjB,CAA3C;;AAEA,SAASpC,aAAT,CAAuByC,KAAvB,EAA8B;AAC5B,MAAIC,eAAe,GAAG,KAAtB;AACA,MAAIC,SAAS,GAAG,IAAhB;AACA,MAAIC,SAAS,GAAGH,KAAhB;AACA,MAAII,CAAC,GAAGD,SAAS,CAACE,KAAV,CAAgBT,iBAAhB,CAAR;;AAEA,MAAIQ,CAAJ,EAAO;AACLF,IAAAA,SAAS,GAAGE,CAAC,CAAC,CAAD,CAAb;AACAD,IAAAA,SAAS,GAAGC,CAAC,CAAC,CAAD,CAAb;AACD;;AAEDD,EAAAA,SAAS,GAAG,CAAC,GAAGxC,MAAM,CAAC,SAAD,CAAV,EAAuBwC,SAAvB,CAAZ;;AAEA,MAAIA,SAAS,KAAKH,KAAlB,EAAyB;AACvBC,IAAAA,eAAe,GAAG,IAAlB;AACD;;AAED,SAAO;AACLA,IAAAA,eAAe,EAAEA,eADZ;AAELE,IAAAA,SAAS,EAAEA,SAFN;AAGLD,IAAAA,SAAS,EAAEA;AAHN,GAAP;AAKD;;AAED,SAASI,8BAAT,CAAwCC,IAAxC,EAA8C;AAC5C,MAAIA,IAAI,CAACL,SAAL,KAAmBM,SAAvB,EAAkC;AAChC,WAAOD,IAAP;AACD;;AAED,MAAIA,IAAI,CAACP,KAAL,KAAeQ,SAAnB,EAA8B;AAC5B,WAAOD,IAAP;AACD;;AAEDR,EAAAA,2BAA2B;;AAE3B,MAAIU,cAAc,GAAGlD,aAAa,CAACgD,IAAI,CAACP,KAAN,CAAlC;AAAA,MACIE,SAAS,GAAGO,cAAc,CAACP,SAD/B;AAAA,MAEIC,SAAS,GAAGM,cAAc,CAACN,SAF/B;;AAIA,MAAI,CAACI,IAAI,CAACG,IAAV,EAAgB;AACdH,IAAAA,IAAI,CAACG,IAAL,GAAY,EAAZ;AACD;;AAED,MAAIH,IAAI,CAACG,IAAL,CAAUV,KAAV,KAAoBQ,SAAxB,EAAmC;AACjCD,IAAAA,IAAI,CAACG,IAAL,CAAUV,KAAV,GAAkBO,IAAI,CAACP,KAAvB;AACD;;AAEDO,EAAAA,IAAI,CAACP,KAAL,GAAaG,SAAb;AACAI,EAAAA,IAAI,CAACL,SAAL,GAAiBA,SAAjB;AACA,SAAOK,IAAP;AACD;;AAED,IAAII,SAAS,GAAG,aAAa,UAAUC,UAAV,EAAsB;AACjD3B,EAAAA,cAAc,CAAC0B,SAAD,EAAYC,UAAZ,CAAd;;AAEA,WAASD,SAAT,CAAmBJ,IAAnB,EAAyB;AACvB,QAAIM,KAAJ;;AAEA,QAAIN,IAAI,KAAK,KAAK,CAAlB,EAAqB;AACnBA,MAAAA,IAAI,GAAG,EAAP;AACD;;AAEDM,IAAAA,KAAK,GAAGD,UAAU,CAACE,IAAX,CAAgB,IAAhB,EAAsBR,8BAA8B,CAACC,IAAD,CAApD,KAA+D,IAAvE;AACAM,IAAAA,KAAK,CAACE,IAAN,GAAalD,MAAM,CAACmD,SAApB;AACAH,IAAAA,KAAK,CAACH,IAAN,GAAaG,KAAK,CAACH,IAAN,IAAc,EAA3B;AACAjC,IAAAA,MAAM,CAACC,cAAP,CAAsBmC,KAAK,CAACH,IAA5B,EAAkC,UAAlC,EAA8C;AAC5CO,MAAAA,GAAG,EAAEtB,SAAS,CAAC,YAAY;AACzB,eAAOkB,KAAK,CAACb,KAAb;AACD,OAFa,EAEX,4DAFW,CAD8B;AAI5CkB,MAAAA,GAAG,EAAEvB,SAAS,CAAC,YAAY;AACzB,eAAOkB,KAAK,CAACb,KAAb;AACD,OAFa,EAEX,qGAFW;AAJ8B,KAA9C;AAQAa,IAAAA,KAAK,CAACM,YAAN,GAAqB,IAArB;AACA,WAAON,KAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE,MAAIO,MAAM,GAAGT,SAAS,CAAC3B,SAAvB;;AAEAoC,EAAAA,MAAM,CAACC,cAAP,GAAwB,SAASA,cAAT,CAAwBC,OAAxB,EAAiC;AACvD,QAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AACtBA,MAAAA,OAAO,GAAG,EAAV;AACD;;AAED,QAAIpB,SAAS,GAAG,KAAKqB,mBAAL,CAAyBD,OAAzB,CAAhB;;AAEA,QAAIE,UAAU,GAAGC,oBAAoB,CAACvB,SAAD,CAArC;AACA,QAAIwB,OAAO,GAAG,CAAC,GAAGlE,OAAO,CAAC,SAAD,CAAX,EAAwB,KAAKmE,MAA7B,EAAqCH,UAArC,CAAd;AACA,WAAOE,OAAP;AACD,GAVD;;AAYAN,EAAAA,MAAM,CAACG,mBAAP,GAA6B,SAASA,mBAAT,CAA6BD,OAA7B,EAAsC;AACjE,WAAOA,OAAO,CAACM,KAAR,GAAgB,KAAKC,cAAL,CAAoBP,OAApB,CAAhB,GAA+C,KAAKQ,kBAAL,CAAwBR,OAAxB,CAAtD;AACD;AACD;AACF;AACA;AACA;AACA;AAPE;;AAUAF,EAAAA,MAAM,CAACW,QAAP,GAAkB,SAASA,QAAT,CAAkB/B,KAAlB,EAAyBsB,OAAzB,EAAkC;AAClD,QAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AACtBA,MAAAA,OAAO,GAAG,EAAV;AACD;;AAED,SAAKK,MAAL,GAAc3B,KAAd;AACA,SAAKgC,UAAL,GAAkB,KAAKT,mBAAL,CAAyBD,OAAzB,CAAlB;;AAEA,SAAKW,aAAL;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBE;;AAwBAb,EAAAA,MAAM,CAACS,cAAP,GAAwB,SAASA,cAAT,CAAwBP,OAAxB,EAAiC;AACvD,QAAIY,CAAC,GAAG,KAAKlC,KAAb;AACA,QAAImC,eAAe,GAAGD,CAAC,CAACE,OAAF,CAAU,OAAV,EAAmB,EAAnB,EAAuBhE,MAA7C;AACA,QAAIiE,eAAe,GAAGH,CAAC,CAACE,OAAF,CAAU,OAAV,EAAmB,EAAnB,EAAuBhE,MAA7C;;AAEA,QAAI+D,eAAe,GAAGE,eAAlB,KAAsC,CAA1C,EAA6C;AAC3C,UAAIX,OAAO,GAAG,CAAC,GAAGlE,OAAO,CAAC,SAAD,CAAX,EAAwB0E,CAAxB,EAA2B;AACvCI,QAAAA,YAAY,EAAE;AADyB,OAA3B,CAAd;;AAIA,UAAIZ,OAAO,KAAKQ,CAAhB,EAAmB;AACjB,eAAOvB,SAAS,CAAC4B,QAAjB;AACD,OAFD,MAEO;AACL,YAAIC,IAAI,GAAG,KAAKV,kBAAL,CAAwBR,OAAxB,CAAX;;AAEA,YAAIkB,IAAI,KAAK7B,SAAS,CAAC4B,QAAvB,EAAiC;AAC/B;AACA,cAAIE,KAAK,GAAG,KAAKvC,SAAL,IAAkBoB,OAAO,CAACpB,SAA1B,IAAuCS,SAAS,CAAC+B,YAA7D;AACA,cAAInC,IAAI,GAAGkB,oBAAoB,CAACgB,KAAD,CAA/B;AACA,cAAIE,UAAU,GAAG,CAAC,GAAGnF,OAAO,CAAC,SAAD,CAAX,EAAwB0E,CAAxB,EAA2B3B,IAA3B,CAAjB;;AAEA,cAAIoC,UAAU,CAACvE,MAAX,GAAoBsD,OAAO,CAACtD,MAAhC,EAAwC;AACtC,mBAAOqE,KAAP;AACD;AACF;;AAED,eAAOD,IAAP;AACD;AACF,KAvBD,MAuBO,IAAIH,eAAe,KAAKF,eAAxB,EAAyC;AAC9C,aAAO,KAAKL,kBAAL,CAAwBR,OAAxB,CAAP;AACD,KAFM,MAEA,IAAIe,eAAe,GAAGF,eAAtB,EAAuC;AAC5C,aAAOxB,SAAS,CAAC+B,YAAjB;AACD,KAFM,MAEA;AACL,aAAO/B,SAAS,CAACiC,YAAjB;AACD;AACF;AACD;AACF;AACA;AACA;AACA;AAxCE;;AA2CAxB,EAAAA,MAAM,CAACU,kBAAP,GAA4B,SAASA,kBAAT,CAA4BR,OAA5B,EAAqC;AAC/D,QAAIpB,SAAS,GAAGoB,OAAO,CAACuB,sBAAR,GAAiC,KAAK3C,SAAtC,GAAkDoB,OAAO,CAACpB,SAA1E;;AAEA,QAAIA,SAAS,KAAKM,SAAlB,EAA6B;AAC3BN,MAAAA,SAAS,GAAGoB,OAAO,CAACuB,sBAAR,GAAiCvB,OAAO,CAACpB,SAAzC,GAAqD,KAAKA,SAAtE;AACD;;AAED,QAAIA,SAAS,KAAKM,SAAlB,EAA6B;AAC3BN,MAAAA,SAAS,GAAGS,SAAS,CAAC+B,YAAtB;AACD;;AAED,WAAOxC,SAAP;AACD,GAZD;;AAcAkB,EAAAA,MAAM,CAACa,aAAP,GAAuB,SAASA,aAAT,GAAyB;AAC9C,QAAIa,QAAQ,GAAG,CAAC,GAAGtF,OAAO,CAAC,SAAD,CAAX,EAAwB,KAAKmE,MAA7B,EAAqCF,oBAAoB,CAAC,KAAKvB,SAAN,CAAzD,CAAf;;AAEA,QAAI4C,QAAQ,KAAK,KAAKnB,MAAtB,EAA8B;AAC5B,UAAI,KAAKjB,IAAT,EAAe;AACb,eAAO,KAAKA,IAAL,CAAUV,KAAjB;AACD;AACF,KAJD,MAIO;AACL,WAAKU,IAAL,CAAUV,KAAV,GAAkB8C,QAAlB;AACD;AACF,GAVD;;AAYA1B,EAAAA,MAAM,CAAC2B,cAAP,GAAwB,SAASA,cAAT,CAAwBC,IAAxB,EAA8BhD,KAA9B,EAAqC;AAC3D,QAAI,KAAKmB,YAAT,EAAuB;AACrB,UAAIO,OAAO,GAAG,CAAC,GAAGlE,OAAO,CAAC,SAAD,CAAX,EAAwBwC,KAAxB,EAA+B;AAC3CsC,QAAAA,YAAY,EAAE;AAD6B,OAA/B,CAAd;;AAIA,UAAIZ,OAAO,KAAK1B,KAAhB,EAAuB;AACrB,aAAKU,IAAL,CAAUsC,IAAV,IAAkBtB,OAAlB;AACD,OAFD,MAEO;AACL,eAAO,KAAKhB,IAAL,CAAUsC,IAAV,CAAP;AACD;AACF;AACF,GAZD;;AAcA5B,EAAAA,MAAM,CAAC6B,UAAP,GAAoB,SAASA,UAAT,CAAoBC,IAApB,EAA0B;AAC5C,QAAIC,UAAU,GAAG;AACfC,MAAAA,MAAM,EAAE,EADO;AAEfC,MAAAA,KAAK,EAAE;AAFQ,KAAjB;AAIA,QAAIC,MAAM,GAAG,KAAKA,MAAL,CAAYJ,IAAZ,KAAqB,EAAlC;AACA,QAAIK,SAAS,GAAG,KAAK7C,IAAL,CAAU4C,MAAV,IAAoB,KAAK5C,IAAL,CAAU4C,MAAV,CAAiBJ,IAAjB,CAApB,IAA8C,EAA9D;AACA,WAAOzE,MAAM,CAAC+E,MAAP,CAAcL,UAAd,EAA0BG,MAA1B,EAAkCC,SAAlC,CAAP;AACD,GARD;;AAUAnC,EAAAA,MAAM,CAACqC,UAAP,GAAoB,SAASA,UAAT,CAAoBP,IAApB,EAA0BQ,SAA1B,EAAqCC,MAArC,EAA6C;AAC/D,QAAID,SAAS,KAAK,KAAK,CAAvB,EAA0B;AACxBA,MAAAA,SAAS,GAAGR,IAAZ;AACD;;AAED,QAAIS,MAAM,KAAK,KAAK,CAApB,EAAuB;AACrBA,MAAAA,MAAM,GAAGC,iBAAT;AACD;;AAED,QAAIT,UAAU,GAAG,KAAKF,UAAL,CAAgBS,SAAhB,CAAjB;;AAEA,WAAOC,MAAM,CAAC,KAAKE,iBAAL,CAAuBX,IAAvB,CAAD,EAA+BC,UAA/B,CAAb;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1BE;;AA6BA/B,EAAAA,MAAM,CAAC0C,QAAP,GAAkB,SAASA,QAAT,CAAkBZ,IAAlB,EAAwB;AACxC,QAAIa,KAAK,GAAG,CAAZ;;AAEA,QAAIC,eAAe,GAAG,KAAKf,UAAL,CAAgB,WAAhB,CAAtB;;AAEAc,IAAAA,KAAK,IAAIC,eAAe,CAACZ,MAAhB,CAAuBhF,MAAhC;;AAEA,QAAI8E,IAAI,KAAK,WAAT,IAAwBA,IAAI,KAAK,IAArC,EAA2C;AACzC,aAAO,KAAKe,SAAL,GAAiBF,KAAjB,GAAyB,CAAC,CAAjC;AACD;;AAED,QAAIb,IAAI,KAAK,aAAb,EAA4B;AAC1B,aAAOa,KAAP;AACD;;AAEDA,IAAAA,KAAK,IAAI,KAAKG,eAAL,CAAqB9F,MAA9B;;AAEA,QAAI,KAAK6F,SAAT,EAAoB;AAClBF,MAAAA,KAAK,IAAI,CAAT;AACD;;AAED,QAAIb,IAAI,KAAK,WAAb,EAA0B;AACxB,aAAOa,KAAP;AACD;;AAEDA,IAAAA,KAAK,IAAI,KAAKF,iBAAL,CAAuB,WAAvB,EAAoCzF,MAA7C;AACA2F,IAAAA,KAAK,IAAIC,eAAe,CAACX,KAAhB,CAAsBjF,MAA/B;;AAEA,QAAI+F,cAAc,GAAG,KAAKlB,UAAL,CAAgB,UAAhB,CAArB;;AAEAc,IAAAA,KAAK,IAAII,cAAc,CAACf,MAAf,CAAsBhF,MAA/B;AACA,QAAIgG,QAAQ,GAAG,KAAKP,iBAAL,CAAuB,UAAvB,CAAf;;AAEA,QAAIX,IAAI,KAAK,UAAb,EAAyB;AACvB,aAAOkB,QAAQ,GAAGL,KAAH,GAAW,CAAC,CAA3B;AACD;;AAEDA,IAAAA,KAAK,IAAIK,QAAQ,CAAChG,MAAlB;AACA2F,IAAAA,KAAK,IAAII,cAAc,CAACd,KAAf,CAAqBjF,MAA9B;;AAEA,QAAIiG,WAAW,GAAG,KAAKpB,UAAL,CAAgB,OAAhB,CAAlB;;AAEAc,IAAAA,KAAK,IAAIM,WAAW,CAACjB,MAAZ,CAAmBhF,MAA5B;AACA,QAAI4B,KAAK,GAAG,KAAK6D,iBAAL,CAAuB,OAAvB,CAAZ;;AAEA,QAAIX,IAAI,KAAK,OAAb,EAAsB;AACpB,aAAOlD,KAAK,GAAG+D,KAAH,GAAW,CAAC,CAAxB;AACD;;AAEDA,IAAAA,KAAK,IAAI/D,KAAK,CAAC5B,MAAf;AACA2F,IAAAA,KAAK,IAAIM,WAAW,CAAChB,KAAZ,CAAkBjF,MAA3B;;AAEA,QAAIkG,iBAAiB,GAAG,KAAKrB,UAAL,CAAgB,aAAhB,CAAxB;;AAEAc,IAAAA,KAAK,IAAIO,iBAAiB,CAAClB,MAAlB,CAAyBhF,MAAlC;;AAEA,QAAI8E,IAAI,KAAK,aAAb,EAA4B;AAC1B,aAAO,KAAKqB,WAAL,GAAmBR,KAAnB,GAA2B,CAAC,CAAnC;AACD;;AAED,WAAO,CAAC,CAAR;AACD,GA7DD;;AA+DA3C,EAAAA,MAAM,CAACoD,QAAP,GAAkB,SAASA,QAAT,GAAoB;AACpC,QAAIC,MAAM,GAAG,IAAb;;AAEA,QAAIC,QAAQ,GAAG,CAAC,KAAKC,cAAN,EAAsB,GAAtB,CAAf;AACAD,IAAAA,QAAQ,CAACE,IAAT,CAAc,KAAKnB,UAAL,CAAgB,oBAAhB,EAAsC,WAAtC,CAAd;;AAEA,QAAI,KAAKW,QAAL,KAAkB,KAAKpE,KAAL,IAAc,KAAKA,KAAL,KAAe,EAA/C,CAAJ,EAAwD;AACtD0E,MAAAA,QAAQ,CAACE,IAAT,CAAc,KAAKnB,UAAL,CAAgB,UAAhB,CAAd;AACAiB,MAAAA,QAAQ,CAACE,IAAT,CAAc,KAAKnB,UAAL,CAAgB,OAAhB,CAAd;AACAiB,MAAAA,QAAQ,CAACE,IAAT,CAAc,KAAKnB,UAAL,CAAgB,iBAAhB,EAAmC,aAAnC,EAAkD,UAAUoB,SAAV,EAAqB1B,UAArB,EAAiC;AAC/F,YAAI0B,SAAS,CAACzG,MAAV,GAAmB,CAAnB,IAAwB,CAACqG,MAAM,CAACK,MAAhC,IAA0C3B,UAAU,CAACC,MAAX,CAAkBhF,MAAlB,KAA6B,CAAvE,IAA4E,EAAEqG,MAAM,CAACnB,MAAP,CAActD,KAAd,IAAuByE,MAAM,CAACnB,MAAP,CAActD,KAAd,CAAoBqD,KAA7C,CAAhF,EAAqI;AACnIF,UAAAA,UAAU,CAACC,MAAX,GAAoB,GAApB;AACD;;AAED,eAAOQ,iBAAiB,CAACiB,SAAD,EAAY1B,UAAZ,CAAxB;AACD,OANa,CAAd;AAOD;;AAEDuB,IAAAA,QAAQ,CAACE,IAAT,CAAc,GAAd;AACAF,IAAAA,QAAQ,CAACE,IAAT,CAAc,KAAKG,aAAnB;AACA,WAAOL,QAAQ,CAACM,IAAT,CAAc,EAAd,CAAP;AACD,GArBD;;AAuBApG,EAAAA,YAAY,CAAC+B,SAAD,EAAY,CAAC;AACvBhC,IAAAA,GAAG,EAAE,QADkB;AAEvBsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,UAAIgE,EAAE,GAAG,KAAK/E,SAAd;AACA,aAAO+E,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAA5B;AACD,KALsB;AAMvB/D,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAalB,KAAb,EAAoB;AACvBF,MAAAA,gCAAgC;AACjC;AACD;AACJ;AACA;AACA;AACA;AACA;;AAd2B,GAAD,EAgBrB;AACDnB,IAAAA,GAAG,EAAE,WADJ;AAEDsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKe,UAAZ;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AAXK;AAaDd,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAahB,SAAb,EAAwB;AAC3B,UAAI,CAAC,KAAKiB,YAAV,EAAwB;AACtB,aAAKa,UAAL,GAAkB9B,SAAlB;AACA;AACD;;AAED,UAAI,KAAK8B,UAAL,KAAoB9B,SAAxB,EAAmC;AACjC,aAAK8B,UAAL,GAAkB9B,SAAlB;;AAEA,aAAK+B,aAAL;AACD;AACF;AAxBA,GAhBqB,EAyCrB;AACDtD,IAAAA,GAAG,EAAE,oBADJ;AAEDsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKiE,aAAL,CAAmB,KAAKxE,IAAL,CAAUyE,SAAV,IAAuB,KAAKA,SAA/C,CAAP;AACD;AAJA,GAzCqB,EA8CrB;AACDxG,IAAAA,GAAG,EAAE,iBADJ;AAEDsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKsD,WAAL,GAAmB,GAAnB,GAAyB,EAAhC;AACD;AAJA,GA9CqB,EAmDrB;AACD5F,IAAAA,GAAG,EAAE,OADJ;AAEDsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKU,MAAZ;AACD;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBK;AAkBDT,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAagB,CAAb,EAAgB;AACnB,UAAI,KAAKf,YAAT,EAAuB;AACrB,YAAIiE,eAAe,GAAG7H,aAAa,CAAC2E,CAAD,CAAnC;AAAA,YACIjC,eAAe,GAAGmF,eAAe,CAACnF,eADtC;AAAA,YAEIE,SAAS,GAAGiF,eAAe,CAACjF,SAFhC;AAAA,YAGID,SAAS,GAAGkF,eAAe,CAAClF,SAHhC;;AAKA,YAAID,eAAJ,EAAqB;AACnBJ,UAAAA,+BAA+B;AAChC;;AAED,YAAIM,SAAS,KAAK,KAAKwB,MAAnB,IAA6BzB,SAAS,KAAK,KAAK8B,UAApD,EAAgE;AAC9D;AACD;;AAED,aAAKL,MAAL,GAAcxB,SAAd;AACA,aAAK6B,UAAL,GAAkB9B,SAAlB;;AAEA,aAAK+B,aAAL;AACD,OAlBD,MAkBO;AACL,aAAKN,MAAL,GAAcO,CAAd;AACD;AACF;AAxCA,GAnDqB,EA4FrB;AACDvD,IAAAA,GAAG,EAAE,WADJ;AAEDsC,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKoE,UAAZ;AACD,KAJA;AAKDnE,IAAAA,GAAG,EAAE,SAASA,GAAT,CAAagC,IAAb,EAAmB;AACtB,WAAKH,cAAL,CAAoB,WAApB,EAAiCG,IAAjC;;AAEA,WAAKmC,UAAL,GAAkBnC,IAAlB;AACD;AATA,GA5FqB,CAAZ,CAAZ;;AAwGA,SAAOvC,SAAP;AACD,CAxZ4B,CAwZ3B/C,UAAU,CAAC,SAAD,CAxZiB,CAA7B;;AA0ZAP,OAAO,CAAC,SAAD,CAAP,GAAqBsD,SAArB;AACAA,SAAS,CAAC4B,QAAV,GAAqB,IAArB;AACA5B,SAAS,CAACiC,YAAV,GAAyB,GAAzB;AACAjC,SAAS,CAAC+B,YAAV,GAAyB,GAAzB;AACA,IAAIjB,oBAAoB,IAAI3D,qBAAqB,GAAG;AAClD,OAAK;AACHwH,IAAAA,MAAM,EAAE,QADL;AAEHC,IAAAA,IAAI,EAAE;AAFH,GAD6C;AAKlD,OAAK;AACHD,IAAAA,MAAM,EAAE,QADL;AAEHC,IAAAA,IAAI,EAAE;AAFH;AAL6C,CAAxB,EASzBzH,qBAAqB,CAAC,IAAD,CAArB,GAA8B;AAC/BwE,EAAAA,YAAY,EAAE;AADiB,CATL,EAWzBxE,qBAXqB,CAAxB;;AAaA,SAAS8F,iBAAT,CAA2BiB,SAA3B,EAAsC1B,UAAtC,EAAkD;AAChD,SAAO,KAAKA,UAAU,CAACC,MAAhB,GAAyByB,SAAzB,GAAqC1B,UAAU,CAACE,KAAvD;AACD","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.unescapeValue = unescapeValue;\nexports[\"default\"] = void 0;\n\nvar _cssesc = _interopRequireDefault(require(\"cssesc\"));\n\nvar _unesc = _interopRequireDefault(require(\"../util/unesc\"));\n\nvar _namespace = _interopRequireDefault(require(\"./namespace\"));\n\nvar _types = require(\"./types\");\n\nvar _CSSESC_QUOTE_OPTIONS;\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar deprecate = require(\"util-deprecate\");\n\nvar WRAPPED_IN_QUOTES = /^('|\")([^]*)\\1$/;\nvar warnOfDeprecatedValueAssignment = deprecate(function () {}, \"Assigning an attribute a value containing characters that might need to be escaped is deprecated. \" + \"Call attribute.setValue() instead.\");\nvar warnOfDeprecatedQuotedAssignment = deprecate(function () {}, \"Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.\");\nvar warnOfDeprecatedConstructor = deprecate(function () {}, \"Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.\");\n\nfunction unescapeValue(value) {\n  var deprecatedUsage = false;\n  var quoteMark = null;\n  var unescaped = value;\n  var m = unescaped.match(WRAPPED_IN_QUOTES);\n\n  if (m) {\n    quoteMark = m[1];\n    unescaped = m[2];\n  }\n\n  unescaped = (0, _unesc[\"default\"])(unescaped);\n\n  if (unescaped !== value) {\n    deprecatedUsage = true;\n  }\n\n  return {\n    deprecatedUsage: deprecatedUsage,\n    unescaped: unescaped,\n    quoteMark: quoteMark\n  };\n}\n\nfunction handleDeprecatedContructorOpts(opts) {\n  if (opts.quoteMark !== undefined) {\n    return opts;\n  }\n\n  if (opts.value === undefined) {\n    return opts;\n  }\n\n  warnOfDeprecatedConstructor();\n\n  var _unescapeValue = unescapeValue(opts.value),\n      quoteMark = _unescapeValue.quoteMark,\n      unescaped = _unescapeValue.unescaped;\n\n  if (!opts.raws) {\n    opts.raws = {};\n  }\n\n  if (opts.raws.value === undefined) {\n    opts.raws.value = opts.value;\n  }\n\n  opts.value = unescaped;\n  opts.quoteMark = quoteMark;\n  return opts;\n}\n\nvar Attribute = /*#__PURE__*/function (_Namespace) {\n  _inheritsLoose(Attribute, _Namespace);\n\n  function Attribute(opts) {\n    var _this;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;\n    _this.type = _types.ATTRIBUTE;\n    _this.raws = _this.raws || {};\n    Object.defineProperty(_this.raws, 'unquoted', {\n      get: deprecate(function () {\n        return _this.value;\n      }, \"attr.raws.unquoted is deprecated. Call attr.value instead.\"),\n      set: deprecate(function () {\n        return _this.value;\n      }, \"Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.\")\n    });\n    _this._constructed = true;\n    return _this;\n  }\n  /**\n   * Returns the Attribute's value quoted such that it would be legal to use\n   * in the value of a css file. The original value's quotation setting\n   * used for stringification is left unchanged. See `setValue(value, options)`\n   * if you want to control the quote settings of a new value for the attribute.\n   *\n   * You can also change the quotation used for the current value by setting quoteMark.\n   *\n   * Options:\n   *   * quoteMark {'\"' | \"'\" | null} - Use this value to quote the value. If this\n   *     option is not set, the original value for quoteMark will be used. If\n   *     indeterminate, a double quote is used. The legal values are:\n   *     * `null` - the value will be unquoted and characters will be escaped as necessary.\n   *     * `'` - the value will be quoted with a single quote and single quotes are escaped.\n   *     * `\"` - the value will be quoted with a double quote and double quotes are escaped.\n   *   * preferCurrentQuoteMark {boolean} - if true, prefer the source quote mark\n   *     over the quoteMark option value.\n   *   * smart {boolean} - if true, will select a quote mark based on the value\n   *     and the other options specified here. See the `smartQuoteMark()`\n   *     method.\n   **/\n\n\n  var _proto = Attribute.prototype;\n\n  _proto.getQuotedValue = function getQuotedValue(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var quoteMark = this._determineQuoteMark(options);\n\n    var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];\n    var escaped = (0, _cssesc[\"default\"])(this._value, cssescopts);\n    return escaped;\n  };\n\n  _proto._determineQuoteMark = function _determineQuoteMark(options) {\n    return options.smart ? this.smartQuoteMark(options) : this.preferredQuoteMark(options);\n  }\n  /**\n   * Set the unescaped value with the specified quotation options. The value\n   * provided must not include any wrapping quote marks -- those quotes will\n   * be interpreted as part of the value and escaped accordingly.\n   */\n  ;\n\n  _proto.setValue = function setValue(value, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this._value = value;\n    this._quoteMark = this._determineQuoteMark(options);\n\n    this._syncRawValue();\n  }\n  /**\n   * Intelligently select a quoteMark value based on the value's contents. If\n   * the value is a legal CSS ident, it will not be quoted. Otherwise a quote\n   * mark will be picked that minimizes the number of escapes.\n   *\n   * If there's no clear winner, the quote mark from these options is used,\n   * then the source quote mark (this is inverted if `preferCurrentQuoteMark` is\n   * true). If the quoteMark is unspecified, a double quote is used.\n   *\n   * @param options This takes the quoteMark and preferCurrentQuoteMark options\n   * from the quoteValue method.\n   */\n  ;\n\n  _proto.smartQuoteMark = function smartQuoteMark(options) {\n    var v = this.value;\n    var numSingleQuotes = v.replace(/[^']/g, '').length;\n    var numDoubleQuotes = v.replace(/[^\"]/g, '').length;\n\n    if (numSingleQuotes + numDoubleQuotes === 0) {\n      var escaped = (0, _cssesc[\"default\"])(v, {\n        isIdentifier: true\n      });\n\n      if (escaped === v) {\n        return Attribute.NO_QUOTE;\n      } else {\n        var pref = this.preferredQuoteMark(options);\n\n        if (pref === Attribute.NO_QUOTE) {\n          // pick a quote mark that isn't none and see if it's smaller\n          var quote = this.quoteMark || options.quoteMark || Attribute.DOUBLE_QUOTE;\n          var opts = CSSESC_QUOTE_OPTIONS[quote];\n          var quoteValue = (0, _cssesc[\"default\"])(v, opts);\n\n          if (quoteValue.length < escaped.length) {\n            return quote;\n          }\n        }\n\n        return pref;\n      }\n    } else if (numDoubleQuotes === numSingleQuotes) {\n      return this.preferredQuoteMark(options);\n    } else if (numDoubleQuotes < numSingleQuotes) {\n      return Attribute.DOUBLE_QUOTE;\n    } else {\n      return Attribute.SINGLE_QUOTE;\n    }\n  }\n  /**\n   * Selects the preferred quote mark based on the options and the current quote mark value.\n   * If you want the quote mark to depend on the attribute value, call `smartQuoteMark(opts)`\n   * instead.\n   */\n  ;\n\n  _proto.preferredQuoteMark = function preferredQuoteMark(options) {\n    var quoteMark = options.preferCurrentQuoteMark ? this.quoteMark : options.quoteMark;\n\n    if (quoteMark === undefined) {\n      quoteMark = options.preferCurrentQuoteMark ? options.quoteMark : this.quoteMark;\n    }\n\n    if (quoteMark === undefined) {\n      quoteMark = Attribute.DOUBLE_QUOTE;\n    }\n\n    return quoteMark;\n  };\n\n  _proto._syncRawValue = function _syncRawValue() {\n    var rawValue = (0, _cssesc[\"default\"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);\n\n    if (rawValue === this._value) {\n      if (this.raws) {\n        delete this.raws.value;\n      }\n    } else {\n      this.raws.value = rawValue;\n    }\n  };\n\n  _proto._handleEscapes = function _handleEscapes(prop, value) {\n    if (this._constructed) {\n      var escaped = (0, _cssesc[\"default\"])(value, {\n        isIdentifier: true\n      });\n\n      if (escaped !== value) {\n        this.raws[prop] = escaped;\n      } else {\n        delete this.raws[prop];\n      }\n    }\n  };\n\n  _proto._spacesFor = function _spacesFor(name) {\n    var attrSpaces = {\n      before: '',\n      after: ''\n    };\n    var spaces = this.spaces[name] || {};\n    var rawSpaces = this.raws.spaces && this.raws.spaces[name] || {};\n    return Object.assign(attrSpaces, spaces, rawSpaces);\n  };\n\n  _proto._stringFor = function _stringFor(name, spaceName, concat) {\n    if (spaceName === void 0) {\n      spaceName = name;\n    }\n\n    if (concat === void 0) {\n      concat = defaultAttrConcat;\n    }\n\n    var attrSpaces = this._spacesFor(spaceName);\n\n    return concat(this.stringifyProperty(name), attrSpaces);\n  }\n  /**\n   * returns the offset of the attribute part specified relative to the\n   * start of the node of the output string.\n   *\n   * * \"ns\" - alias for \"namespace\"\n   * * \"namespace\" - the namespace if it exists.\n   * * \"attribute\" - the attribute name\n   * * \"attributeNS\" - the start of the attribute or its namespace\n   * * \"operator\" - the match operator of the attribute\n   * * \"value\" - The value (string or identifier)\n   * * \"insensitive\" - the case insensitivity flag;\n   * @param part One of the possible values inside an attribute.\n   * @returns -1 if the name is invalid or the value doesn't exist in this attribute.\n   */\n  ;\n\n  _proto.offsetOf = function offsetOf(name) {\n    var count = 1;\n\n    var attributeSpaces = this._spacesFor(\"attribute\");\n\n    count += attributeSpaces.before.length;\n\n    if (name === \"namespace\" || name === \"ns\") {\n      return this.namespace ? count : -1;\n    }\n\n    if (name === \"attributeNS\") {\n      return count;\n    }\n\n    count += this.namespaceString.length;\n\n    if (this.namespace) {\n      count += 1;\n    }\n\n    if (name === \"attribute\") {\n      return count;\n    }\n\n    count += this.stringifyProperty(\"attribute\").length;\n    count += attributeSpaces.after.length;\n\n    var operatorSpaces = this._spacesFor(\"operator\");\n\n    count += operatorSpaces.before.length;\n    var operator = this.stringifyProperty(\"operator\");\n\n    if (name === \"operator\") {\n      return operator ? count : -1;\n    }\n\n    count += operator.length;\n    count += operatorSpaces.after.length;\n\n    var valueSpaces = this._spacesFor(\"value\");\n\n    count += valueSpaces.before.length;\n    var value = this.stringifyProperty(\"value\");\n\n    if (name === \"value\") {\n      return value ? count : -1;\n    }\n\n    count += value.length;\n    count += valueSpaces.after.length;\n\n    var insensitiveSpaces = this._spacesFor(\"insensitive\");\n\n    count += insensitiveSpaces.before.length;\n\n    if (name === \"insensitive\") {\n      return this.insensitive ? count : -1;\n    }\n\n    return -1;\n  };\n\n  _proto.toString = function toString() {\n    var _this2 = this;\n\n    var selector = [this.rawSpaceBefore, '['];\n    selector.push(this._stringFor('qualifiedAttribute', 'attribute'));\n\n    if (this.operator && (this.value || this.value === '')) {\n      selector.push(this._stringFor('operator'));\n      selector.push(this._stringFor('value'));\n      selector.push(this._stringFor('insensitiveFlag', 'insensitive', function (attrValue, attrSpaces) {\n        if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {\n          attrSpaces.before = \" \";\n        }\n\n        return defaultAttrConcat(attrValue, attrSpaces);\n      }));\n    }\n\n    selector.push(']');\n    selector.push(this.rawSpaceAfter);\n    return selector.join('');\n  };\n\n  _createClass(Attribute, [{\n    key: \"quoted\",\n    get: function get() {\n      var qm = this.quoteMark;\n      return qm === \"'\" || qm === '\"';\n    },\n    set: function set(value) {\n      warnOfDeprecatedQuotedAssignment();\n    }\n    /**\n     * returns a single (`'`) or double (`\"`) quote character if the value is quoted.\n     * returns `null` if the value is not quoted.\n     * returns `undefined` if the quotation state is unknown (this can happen when\n     * the attribute is constructed without specifying a quote mark.)\n     */\n\n  }, {\n    key: \"quoteMark\",\n    get: function get() {\n      return this._quoteMark;\n    }\n    /**\n     * Set the quote mark to be used by this attribute's value.\n     * If the quote mark changes, the raw (escaped) value at `attr.raws.value` of the attribute\n     * value is updated accordingly.\n     *\n     * @param {\"'\" | '\"' | null} quoteMark The quote mark or `null` if the value should be unquoted.\n     */\n    ,\n    set: function set(quoteMark) {\n      if (!this._constructed) {\n        this._quoteMark = quoteMark;\n        return;\n      }\n\n      if (this._quoteMark !== quoteMark) {\n        this._quoteMark = quoteMark;\n\n        this._syncRawValue();\n      }\n    }\n  }, {\n    key: \"qualifiedAttribute\",\n    get: function get() {\n      return this.qualifiedName(this.raws.attribute || this.attribute);\n    }\n  }, {\n    key: \"insensitiveFlag\",\n    get: function get() {\n      return this.insensitive ? 'i' : '';\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    }\n    /**\n     * Before 3.0, the value had to be set to an escaped value including any wrapped\n     * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value\n     * is unescaped during parsing and any quote marks are removed.\n     *\n     * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,\n     * a deprecation warning is raised when the new value contains any characters that would\n     * require escaping (including if it contains wrapped quotes).\n     *\n     * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe\n     * how the new value is quoted.\n     */\n    ,\n    set: function set(v) {\n      if (this._constructed) {\n        var _unescapeValue2 = unescapeValue(v),\n            deprecatedUsage = _unescapeValue2.deprecatedUsage,\n            unescaped = _unescapeValue2.unescaped,\n            quoteMark = _unescapeValue2.quoteMark;\n\n        if (deprecatedUsage) {\n          warnOfDeprecatedValueAssignment();\n        }\n\n        if (unescaped === this._value && quoteMark === this._quoteMark) {\n          return;\n        }\n\n        this._value = unescaped;\n        this._quoteMark = quoteMark;\n\n        this._syncRawValue();\n      } else {\n        this._value = v;\n      }\n    }\n  }, {\n    key: \"attribute\",\n    get: function get() {\n      return this._attribute;\n    },\n    set: function set(name) {\n      this._handleEscapes(\"attribute\", name);\n\n      this._attribute = name;\n    }\n  }]);\n\n  return Attribute;\n}(_namespace[\"default\"]);\n\nexports[\"default\"] = Attribute;\nAttribute.NO_QUOTE = null;\nAttribute.SINGLE_QUOTE = \"'\";\nAttribute.DOUBLE_QUOTE = '\"';\nvar CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {\n  \"'\": {\n    quotes: 'single',\n    wrap: true\n  },\n  '\"': {\n    quotes: 'double',\n    wrap: true\n  }\n}, _CSSESC_QUOTE_OPTIONS[null] = {\n  isIdentifier: true\n}, _CSSESC_QUOTE_OPTIONS);\n\nfunction defaultAttrConcat(attrValue, attrSpaces) {\n  return \"\" + attrSpaces.before + attrValue + attrSpaces.after;\n}"]},"metadata":{},"sourceType":"script"}