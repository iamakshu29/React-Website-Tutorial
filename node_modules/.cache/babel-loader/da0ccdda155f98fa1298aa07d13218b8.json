{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = tokenize;\nexports.FIELDS = void 0;\n\nvar t = _interopRequireWildcard(require(\"./tokenTypes\"));\n\nvar _unescapable, _wordDelimiters;\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\nvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\nvar hex = {};\nvar hexChars = \"0123456789abcdefABCDEF\";\n\nfor (var i = 0; i < hexChars.length; i++) {\n  hex[hexChars.charCodeAt(i)] = true;\n}\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\n\n\nfunction consumeWord(css, start) {\n  var next = start;\n  var code;\n\n  do {\n    code = css.charCodeAt(next);\n\n    if (wordDelimiters[code]) {\n      return next - 1;\n    } else if (code === t.backslash) {\n      next = consumeEscape(css, next) + 1;\n    } else {\n      // All other characters are part of the word\n      next++;\n    }\n  } while (next < css.length);\n\n  return next - 1;\n}\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\n\n\nfunction consumeEscape(css, start) {\n  var next = start;\n  var code = css.charCodeAt(next + 1);\n\n  if (unescapable[code]) {// just consume the escape char\n  } else if (hex[code]) {\n    var hexDigits = 0; // consume up to 6 hex chars\n\n    do {\n      next++;\n      hexDigits++;\n      code = css.charCodeAt(next + 1);\n    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape\n\n\n    if (hexDigits < 6 && code === t.space) {\n      next++;\n    }\n  } else {\n    // the next char is part of the current word\n    next++;\n  }\n\n  return next;\n}\n\nvar FIELDS = {\n  TYPE: 0,\n  START_LINE: 1,\n  START_COL: 2,\n  END_LINE: 3,\n  END_COL: 4,\n  START_POS: 5,\n  END_POS: 6\n};\nexports.FIELDS = FIELDS;\n\nfunction tokenize(input) {\n  var tokens = [];\n  var css = input.css.valueOf();\n  var _css = css,\n      length = _css.length;\n  var offset = -1;\n  var line = 1;\n  var start = 0;\n  var end = 0;\n  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\n\n  function unclosed(what, fix) {\n    if (input.safe) {\n      // fyi: this is never set to true.\n      css += fix;\n      next = css.length - 1;\n    } else {\n      throw input.error('Unclosed ' + what, line, start - offset, start);\n    }\n  }\n\n  while (start < length) {\n    code = css.charCodeAt(start);\n\n    if (code === t.newline) {\n      offset = start;\n      line += 1;\n    }\n\n    switch (code) {\n      case t.space:\n      case t.tab:\n      case t.newline:\n      case t.cr:\n      case t.feed:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === t.newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n\n        tokenType = t.space;\n        endLine = line;\n        endColumn = next - offset - 1;\n        end = next;\n        break;\n\n      case t.plus:\n      case t.greaterThan:\n      case t.tilde:\n      case t.pipe:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n\n        tokenType = t.combinator;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n      // Consume these characters as single tokens.\n\n      case t.asterisk:\n      case t.ampersand:\n      case t.bang:\n      case t.comma:\n      case t.equals:\n      case t.dollar:\n      case t.caret:\n      case t.openSquare:\n      case t.closeSquare:\n      case t.colon:\n      case t.semicolon:\n      case t.openParenthesis:\n      case t.closeParenthesis:\n        next = start;\n        tokenType = code;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      case t.singleQuote:\n      case t.doubleQuote:\n        quote = code === t.singleQuote ? \"'\" : '\"';\n        next = start;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokenType = t.str;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      default:\n        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n          next = css.indexOf('*/', start + 2) + 1;\n\n          if (next === 0) {\n            unclosed('comment', '*/');\n          }\n\n          content = css.slice(start, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokenType = t.comment;\n          line = nextLine;\n          endLine = nextLine;\n          endColumn = next - nextOffset;\n        } else if (code === t.slash) {\n          next = start;\n          tokenType = code;\n          endLine = line;\n          endColumn = start - offset;\n          end = next + 1;\n        } else {\n          next = consumeWord(css, start);\n          tokenType = t.word;\n          endLine = line;\n          endColumn = next - offset;\n        }\n\n        end = next + 1;\n        break;\n    } // Ensure that the token structure remains consistent\n\n\n    tokens.push([tokenType, // [0] Token type\n    line, // [1] Starting line\n    start - offset, // [2] Starting column\n    endLine, // [3] Ending line\n    endColumn, // [4] Ending column\n    start, // [5] Start position / Source index\n    end // [6] End position\n    ]); // Reset offset for the next token\n\n    if (nextOffset) {\n      offset = nextOffset;\n      nextOffset = null;\n    }\n\n    start = end;\n  }\n\n  return tokens;\n}","map":{"version":3,"sources":["C:/Users/Akshat Verma/Desktop/Practice/react/react_tut/node_modules/postcss-selector-parser/dist/tokenize.js"],"names":["exports","__esModule","tokenize","FIELDS","t","_interopRequireWildcard","require","_unescapable","_wordDelimiters","_getRequireWildcardCache","WeakMap","cache","obj","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","unescapable","tab","newline","cr","feed","wordDelimiters","space","ampersand","asterisk","bang","comma","colon","semicolon","openParenthesis","closeParenthesis","openSquare","closeSquare","singleQuote","doubleQuote","plus","pipe","tilde","greaterThan","equals","dollar","caret","slash","hex","hexChars","i","length","charCodeAt","consumeWord","css","start","next","code","backslash","consumeEscape","hexDigits","TYPE","START_LINE","START_COL","END_LINE","END_COL","START_POS","END_POS","input","tokens","valueOf","_css","offset","line","end","content","endColumn","endLine","escaped","escapePos","last","lines","nextLine","nextOffset","quote","tokenType","unclosed","what","fix","safe","error","combinator","indexOf","str","slice","split","comment","word","push"],"mappings":"AAAA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAAC,SAAD,CAAP,GAAqBE,QAArB;AACAF,OAAO,CAACG,MAAR,GAAiB,KAAK,CAAtB;;AAEA,IAAIC,CAAC,GAAGC,uBAAuB,CAACC,OAAO,CAAC,cAAD,CAAR,CAA/B;;AAEA,IAAIC,YAAJ,EAAkBC,eAAlB;;AAEA,SAASC,wBAAT,GAAoC;AAAE,MAAI,OAAOC,OAAP,KAAmB,UAAvB,EAAmC,OAAO,IAAP;AAAa,MAAIC,KAAK,GAAG,IAAID,OAAJ,EAAZ;;AAA2BD,EAAAA,wBAAwB,GAAG,SAASA,wBAAT,GAAoC;AAAE,WAAOE,KAAP;AAAe,GAAhF;;AAAkF,SAAOA,KAAP;AAAe;;AAElN,SAASN,uBAAT,CAAiCO,GAAjC,EAAsC;AAAE,MAAIA,GAAG,IAAIA,GAAG,CAACX,UAAf,EAA2B;AAAE,WAAOW,GAAP;AAAa;;AAAC,MAAIA,GAAG,KAAK,IAAR,IAAgB,OAAOA,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,UAA9D,EAA0E;AAAE,WAAO;AAAE,iBAAWA;AAAb,KAAP;AAA4B;;AAAC,MAAID,KAAK,GAAGF,wBAAwB,EAApC;;AAAwC,MAAIE,KAAK,IAAIA,KAAK,CAACE,GAAN,CAAUD,GAAV,CAAb,EAA6B;AAAE,WAAOD,KAAK,CAACG,GAAN,CAAUF,GAAV,CAAP;AAAwB;;AAAC,MAAIG,MAAM,GAAG,EAAb;AAAiB,MAAIC,qBAAqB,GAAGC,MAAM,CAACC,cAAP,IAAyBD,MAAM,CAACE,wBAA5D;;AAAsF,OAAK,IAAIC,GAAT,IAAgBR,GAAhB,EAAqB;AAAE,QAAIK,MAAM,CAACI,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqCX,GAArC,EAA0CQ,GAA1C,CAAJ,EAAoD;AAAE,UAAII,IAAI,GAAGR,qBAAqB,GAAGC,MAAM,CAACE,wBAAP,CAAgCP,GAAhC,EAAqCQ,GAArC,CAAH,GAA+C,IAA/E;;AAAqF,UAAII,IAAI,KAAKA,IAAI,CAACV,GAAL,IAAYU,IAAI,CAACC,GAAtB,CAAR,EAAoC;AAAER,QAAAA,MAAM,CAACC,cAAP,CAAsBH,MAAtB,EAA8BK,GAA9B,EAAmCI,IAAnC;AAA2C,OAAjF,MAAuF;AAAET,QAAAA,MAAM,CAACK,GAAD,CAAN,GAAcR,GAAG,CAACQ,GAAD,CAAjB;AAAyB;AAAE;AAAE;;AAACL,EAAAA,MAAM,CAAC,SAAD,CAAN,GAAoBH,GAApB;;AAAyB,MAAID,KAAJ,EAAW;AAAEA,IAAAA,KAAK,CAACc,GAAN,CAAUb,GAAV,EAAeG,MAAf;AAAyB;;AAAC,SAAOA,MAAP;AAAgB;;AAE5uB,IAAIW,WAAW,IAAInB,YAAY,GAAG,EAAf,EAAmBA,YAAY,CAACH,CAAC,CAACuB,GAAH,CAAZ,GAAsB,IAAzC,EAA+CpB,YAAY,CAACH,CAAC,CAACwB,OAAH,CAAZ,GAA0B,IAAzE,EAA+ErB,YAAY,CAACH,CAAC,CAACyB,EAAH,CAAZ,GAAqB,IAApG,EAA0GtB,YAAY,CAACH,CAAC,CAAC0B,IAAH,CAAZ,GAAuB,IAAjI,EAAuIvB,YAA3I,CAAf;AACA,IAAIwB,cAAc,IAAIvB,eAAe,GAAG,EAAlB,EAAsBA,eAAe,CAACJ,CAAC,CAAC4B,KAAH,CAAf,GAA2B,IAAjD,EAAuDxB,eAAe,CAACJ,CAAC,CAACuB,GAAH,CAAf,GAAyB,IAAhF,EAAsFnB,eAAe,CAACJ,CAAC,CAACwB,OAAH,CAAf,GAA6B,IAAnH,EAAyHpB,eAAe,CAACJ,CAAC,CAACyB,EAAH,CAAf,GAAwB,IAAjJ,EAAuJrB,eAAe,CAACJ,CAAC,CAAC0B,IAAH,CAAf,GAA0B,IAAjL,EAAuLtB,eAAe,CAACJ,CAAC,CAAC6B,SAAH,CAAf,GAA+B,IAAtN,EAA4NzB,eAAe,CAACJ,CAAC,CAAC8B,QAAH,CAAf,GAA8B,IAA1P,EAAgQ1B,eAAe,CAACJ,CAAC,CAAC+B,IAAH,CAAf,GAA0B,IAA1R,EAAgS3B,eAAe,CAACJ,CAAC,CAACgC,KAAH,CAAf,GAA2B,IAA3T,EAAiU5B,eAAe,CAACJ,CAAC,CAACiC,KAAH,CAAf,GAA2B,IAA5V,EAAkW7B,eAAe,CAACJ,CAAC,CAACkC,SAAH,CAAf,GAA+B,IAAjY,EAAuY9B,eAAe,CAACJ,CAAC,CAACmC,eAAH,CAAf,GAAqC,IAA5a,EAAkb/B,eAAe,CAACJ,CAAC,CAACoC,gBAAH,CAAf,GAAsC,IAAxd,EAA8dhC,eAAe,CAACJ,CAAC,CAACqC,UAAH,CAAf,GAAgC,IAA9f,EAAogBjC,eAAe,CAACJ,CAAC,CAACsC,WAAH,CAAf,GAAiC,IAAriB,EAA2iBlC,eAAe,CAACJ,CAAC,CAACuC,WAAH,CAAf,GAAiC,IAA5kB,EAAklBnC,eAAe,CAACJ,CAAC,CAACwC,WAAH,CAAf,GAAiC,IAAnnB,EAAynBpC,eAAe,CAACJ,CAAC,CAACyC,IAAH,CAAf,GAA0B,IAAnpB,EAAypBrC,eAAe,CAACJ,CAAC,CAAC0C,IAAH,CAAf,GAA0B,IAAnrB,EAAyrBtC,eAAe,CAACJ,CAAC,CAAC2C,KAAH,CAAf,GAA2B,IAAptB,EAA0tBvC,eAAe,CAACJ,CAAC,CAAC4C,WAAH,CAAf,GAAiC,IAA3vB,EAAiwBxC,eAAe,CAACJ,CAAC,CAAC6C,MAAH,CAAf,GAA4B,IAA7xB,EAAmyBzC,eAAe,CAACJ,CAAC,CAAC8C,MAAH,CAAf,GAA4B,IAA/zB,EAAq0B1C,eAAe,CAACJ,CAAC,CAAC+C,KAAH,CAAf,GAA2B,IAAh2B,EAAs2B3C,eAAe,CAACJ,CAAC,CAACgD,KAAH,CAAf,GAA2B,IAAj4B,EAAu4B5C,eAA34B,CAAlB;AACA,IAAI6C,GAAG,GAAG,EAAV;AACA,IAAIC,QAAQ,GAAG,wBAAf;;AAEA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,QAAQ,CAACE,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxCF,EAAAA,GAAG,CAACC,QAAQ,CAACG,UAAT,CAAoBF,CAApB,CAAD,CAAH,GAA8B,IAA9B;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASG,WAAT,CAAqBC,GAArB,EAA0BC,KAA1B,EAAiC;AAC/B,MAAIC,IAAI,GAAGD,KAAX;AACA,MAAIE,IAAJ;;AAEA,KAAG;AACDA,IAAAA,IAAI,GAAGH,GAAG,CAACF,UAAJ,CAAeI,IAAf,CAAP;;AAEA,QAAI9B,cAAc,CAAC+B,IAAD,CAAlB,EAA0B;AACxB,aAAOD,IAAI,GAAG,CAAd;AACD,KAFD,MAEO,IAAIC,IAAI,KAAK1D,CAAC,CAAC2D,SAAf,EAA0B;AAC/BF,MAAAA,IAAI,GAAGG,aAAa,CAACL,GAAD,EAAME,IAAN,CAAb,GAA2B,CAAlC;AACD,KAFM,MAEA;AACL;AACAA,MAAAA,IAAI;AACL;AACF,GAXD,QAWSA,IAAI,GAAGF,GAAG,CAACH,MAXpB;;AAaA,SAAOK,IAAI,GAAG,CAAd;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASG,aAAT,CAAuBL,GAAvB,EAA4BC,KAA5B,EAAmC;AACjC,MAAIC,IAAI,GAAGD,KAAX;AACA,MAAIE,IAAI,GAAGH,GAAG,CAACF,UAAJ,CAAeI,IAAI,GAAG,CAAtB,CAAX;;AAEA,MAAInC,WAAW,CAACoC,IAAD,CAAf,EAAuB,CAAC;AACvB,GADD,MACO,IAAIT,GAAG,CAACS,IAAD,CAAP,EAAe;AACpB,QAAIG,SAAS,GAAG,CAAhB,CADoB,CACD;;AAEnB,OAAG;AACDJ,MAAAA,IAAI;AACJI,MAAAA,SAAS;AACTH,MAAAA,IAAI,GAAGH,GAAG,CAACF,UAAJ,CAAeI,IAAI,GAAG,CAAtB,CAAP;AACD,KAJD,QAISR,GAAG,CAACS,IAAD,CAAH,IAAaG,SAAS,GAAG,CAJlC,EAHoB,CAOkB;;;AAGtC,QAAIA,SAAS,GAAG,CAAZ,IAAiBH,IAAI,KAAK1D,CAAC,CAAC4B,KAAhC,EAAuC;AACrC6B,MAAAA,IAAI;AACL;AACF,GAbM,MAaA;AACL;AACAA,IAAAA,IAAI;AACL;;AAED,SAAOA,IAAP;AACD;;AAED,IAAI1D,MAAM,GAAG;AACX+D,EAAAA,IAAI,EAAE,CADK;AAEXC,EAAAA,UAAU,EAAE,CAFD;AAGXC,EAAAA,SAAS,EAAE,CAHA;AAIXC,EAAAA,QAAQ,EAAE,CAJC;AAKXC,EAAAA,OAAO,EAAE,CALE;AAMXC,EAAAA,SAAS,EAAE,CANA;AAOXC,EAAAA,OAAO,EAAE;AAPE,CAAb;AASAxE,OAAO,CAACG,MAAR,GAAiBA,MAAjB;;AAEA,SAASD,QAAT,CAAkBuE,KAAlB,EAAyB;AACvB,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIf,GAAG,GAAGc,KAAK,CAACd,GAAN,CAAUgB,OAAV,EAAV;AACA,MAAIC,IAAI,GAAGjB,GAAX;AAAA,MACIH,MAAM,GAAGoB,IAAI,CAACpB,MADlB;AAEA,MAAIqB,MAAM,GAAG,CAAC,CAAd;AACA,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIlB,KAAK,GAAG,CAAZ;AACA,MAAImB,GAAG,GAAG,CAAV;AACA,MAAIjB,IAAJ,EAAUkB,OAAV,EAAmBC,SAAnB,EAA8BC,OAA9B,EAAuCC,OAAvC,EAAgDC,SAAhD,EAA2DC,IAA3D,EAAiEC,KAAjE,EAAwEzB,IAAxE,EAA8E0B,QAA9E,EAAwFC,UAAxF,EAAoGC,KAApG,EAA2GC,SAA3G;;AAEA,WAASC,QAAT,CAAkBC,IAAlB,EAAwBC,GAAxB,EAA6B;AAC3B,QAAIpB,KAAK,CAACqB,IAAV,EAAgB;AACd;AACAnC,MAAAA,GAAG,IAAIkC,GAAP;AACAhC,MAAAA,IAAI,GAAGF,GAAG,CAACH,MAAJ,GAAa,CAApB;AACD,KAJD,MAIO;AACL,YAAMiB,KAAK,CAACsB,KAAN,CAAY,cAAcH,IAA1B,EAAgCd,IAAhC,EAAsClB,KAAK,GAAGiB,MAA9C,EAAsDjB,KAAtD,CAAN;AACD;AACF;;AAED,SAAOA,KAAK,GAAGJ,MAAf,EAAuB;AACrBM,IAAAA,IAAI,GAAGH,GAAG,CAACF,UAAJ,CAAeG,KAAf,CAAP;;AAEA,QAAIE,IAAI,KAAK1D,CAAC,CAACwB,OAAf,EAAwB;AACtBiD,MAAAA,MAAM,GAAGjB,KAAT;AACAkB,MAAAA,IAAI,IAAI,CAAR;AACD;;AAED,YAAQhB,IAAR;AACE,WAAK1D,CAAC,CAAC4B,KAAP;AACA,WAAK5B,CAAC,CAACuB,GAAP;AACA,WAAKvB,CAAC,CAACwB,OAAP;AACA,WAAKxB,CAAC,CAACyB,EAAP;AACA,WAAKzB,CAAC,CAAC0B,IAAP;AACE+B,QAAAA,IAAI,GAAGD,KAAP;;AAEA,WAAG;AACDC,UAAAA,IAAI,IAAI,CAAR;AACAC,UAAAA,IAAI,GAAGH,GAAG,CAACF,UAAJ,CAAeI,IAAf,CAAP;;AAEA,cAAIC,IAAI,KAAK1D,CAAC,CAACwB,OAAf,EAAwB;AACtBiD,YAAAA,MAAM,GAAGhB,IAAT;AACAiB,YAAAA,IAAI,IAAI,CAAR;AACD;AACF,SARD,QAQShB,IAAI,KAAK1D,CAAC,CAAC4B,KAAX,IAAoB8B,IAAI,KAAK1D,CAAC,CAACwB,OAA/B,IAA0CkC,IAAI,KAAK1D,CAAC,CAACuB,GAArD,IAA4DmC,IAAI,KAAK1D,CAAC,CAACyB,EAAvE,IAA6EiC,IAAI,KAAK1D,CAAC,CAAC0B,IARjG;;AAUA4D,QAAAA,SAAS,GAAGtF,CAAC,CAAC4B,KAAd;AACAkD,QAAAA,OAAO,GAAGJ,IAAV;AACAG,QAAAA,SAAS,GAAGpB,IAAI,GAAGgB,MAAP,GAAgB,CAA5B;AACAE,QAAAA,GAAG,GAAGlB,IAAN;AACA;;AAEF,WAAKzD,CAAC,CAACyC,IAAP;AACA,WAAKzC,CAAC,CAAC4C,WAAP;AACA,WAAK5C,CAAC,CAAC2C,KAAP;AACA,WAAK3C,CAAC,CAAC0C,IAAP;AACEe,QAAAA,IAAI,GAAGD,KAAP;;AAEA,WAAG;AACDC,UAAAA,IAAI,IAAI,CAAR;AACAC,UAAAA,IAAI,GAAGH,GAAG,CAACF,UAAJ,CAAeI,IAAf,CAAP;AACD,SAHD,QAGSC,IAAI,KAAK1D,CAAC,CAACyC,IAAX,IAAmBiB,IAAI,KAAK1D,CAAC,CAAC4C,WAA9B,IAA6Cc,IAAI,KAAK1D,CAAC,CAAC2C,KAAxD,IAAiEe,IAAI,KAAK1D,CAAC,CAAC0C,IAHrF;;AAKA4C,QAAAA,SAAS,GAAGtF,CAAC,CAAC4F,UAAd;AACAd,QAAAA,OAAO,GAAGJ,IAAV;AACAG,QAAAA,SAAS,GAAGrB,KAAK,GAAGiB,MAApB;AACAE,QAAAA,GAAG,GAAGlB,IAAN;AACA;AACF;;AAEA,WAAKzD,CAAC,CAAC8B,QAAP;AACA,WAAK9B,CAAC,CAAC6B,SAAP;AACA,WAAK7B,CAAC,CAAC+B,IAAP;AACA,WAAK/B,CAAC,CAACgC,KAAP;AACA,WAAKhC,CAAC,CAAC6C,MAAP;AACA,WAAK7C,CAAC,CAAC8C,MAAP;AACA,WAAK9C,CAAC,CAAC+C,KAAP;AACA,WAAK/C,CAAC,CAACqC,UAAP;AACA,WAAKrC,CAAC,CAACsC,WAAP;AACA,WAAKtC,CAAC,CAACiC,KAAP;AACA,WAAKjC,CAAC,CAACkC,SAAP;AACA,WAAKlC,CAAC,CAACmC,eAAP;AACA,WAAKnC,CAAC,CAACoC,gBAAP;AACEqB,QAAAA,IAAI,GAAGD,KAAP;AACA8B,QAAAA,SAAS,GAAG5B,IAAZ;AACAoB,QAAAA,OAAO,GAAGJ,IAAV;AACAG,QAAAA,SAAS,GAAGrB,KAAK,GAAGiB,MAApB;AACAE,QAAAA,GAAG,GAAGlB,IAAI,GAAG,CAAb;AACA;;AAEF,WAAKzD,CAAC,CAACuC,WAAP;AACA,WAAKvC,CAAC,CAACwC,WAAP;AACE6C,QAAAA,KAAK,GAAG3B,IAAI,KAAK1D,CAAC,CAACuC,WAAX,GAAyB,GAAzB,GAA+B,GAAvC;AACAkB,QAAAA,IAAI,GAAGD,KAAP;;AAEA,WAAG;AACDuB,UAAAA,OAAO,GAAG,KAAV;AACAtB,UAAAA,IAAI,GAAGF,GAAG,CAACsC,OAAJ,CAAYR,KAAZ,EAAmB5B,IAAI,GAAG,CAA1B,CAAP;;AAEA,cAAIA,IAAI,KAAK,CAAC,CAAd,EAAiB;AACf8B,YAAAA,QAAQ,CAAC,OAAD,EAAUF,KAAV,CAAR;AACD;;AAEDL,UAAAA,SAAS,GAAGvB,IAAZ;;AAEA,iBAAOF,GAAG,CAACF,UAAJ,CAAe2B,SAAS,GAAG,CAA3B,MAAkChF,CAAC,CAAC2D,SAA3C,EAAsD;AACpDqB,YAAAA,SAAS,IAAI,CAAb;AACAD,YAAAA,OAAO,GAAG,CAACA,OAAX;AACD;AACF,SAdD,QAcSA,OAdT;;AAgBAO,QAAAA,SAAS,GAAGtF,CAAC,CAAC8F,GAAd;AACAhB,QAAAA,OAAO,GAAGJ,IAAV;AACAG,QAAAA,SAAS,GAAGrB,KAAK,GAAGiB,MAApB;AACAE,QAAAA,GAAG,GAAGlB,IAAI,GAAG,CAAb;AACA;;AAEF;AACE,YAAIC,IAAI,KAAK1D,CAAC,CAACgD,KAAX,IAAoBO,GAAG,CAACF,UAAJ,CAAeG,KAAK,GAAG,CAAvB,MAA8BxD,CAAC,CAAC8B,QAAxD,EAAkE;AAChE2B,UAAAA,IAAI,GAAGF,GAAG,CAACsC,OAAJ,CAAY,IAAZ,EAAkBrC,KAAK,GAAG,CAA1B,IAA+B,CAAtC;;AAEA,cAAIC,IAAI,KAAK,CAAb,EAAgB;AACd8B,YAAAA,QAAQ,CAAC,SAAD,EAAY,IAAZ,CAAR;AACD;;AAEDX,UAAAA,OAAO,GAAGrB,GAAG,CAACwC,KAAJ,CAAUvC,KAAV,EAAiBC,IAAI,GAAG,CAAxB,CAAV;AACAyB,UAAAA,KAAK,GAAGN,OAAO,CAACoB,KAAR,CAAc,IAAd,CAAR;AACAf,UAAAA,IAAI,GAAGC,KAAK,CAAC9B,MAAN,GAAe,CAAtB;;AAEA,cAAI6B,IAAI,GAAG,CAAX,EAAc;AACZE,YAAAA,QAAQ,GAAGT,IAAI,GAAGO,IAAlB;AACAG,YAAAA,UAAU,GAAG3B,IAAI,GAAGyB,KAAK,CAACD,IAAD,CAAL,CAAY7B,MAAhC;AACD,WAHD,MAGO;AACL+B,YAAAA,QAAQ,GAAGT,IAAX;AACAU,YAAAA,UAAU,GAAGX,MAAb;AACD;;AAEDa,UAAAA,SAAS,GAAGtF,CAAC,CAACiG,OAAd;AACAvB,UAAAA,IAAI,GAAGS,QAAP;AACAL,UAAAA,OAAO,GAAGK,QAAV;AACAN,UAAAA,SAAS,GAAGpB,IAAI,GAAG2B,UAAnB;AACD,SAvBD,MAuBO,IAAI1B,IAAI,KAAK1D,CAAC,CAACgD,KAAf,EAAsB;AAC3BS,UAAAA,IAAI,GAAGD,KAAP;AACA8B,UAAAA,SAAS,GAAG5B,IAAZ;AACAoB,UAAAA,OAAO,GAAGJ,IAAV;AACAG,UAAAA,SAAS,GAAGrB,KAAK,GAAGiB,MAApB;AACAE,UAAAA,GAAG,GAAGlB,IAAI,GAAG,CAAb;AACD,SANM,MAMA;AACLA,UAAAA,IAAI,GAAGH,WAAW,CAACC,GAAD,EAAMC,KAAN,CAAlB;AACA8B,UAAAA,SAAS,GAAGtF,CAAC,CAACkG,IAAd;AACApB,UAAAA,OAAO,GAAGJ,IAAV;AACAG,UAAAA,SAAS,GAAGpB,IAAI,GAAGgB,MAAnB;AACD;;AAEDE,QAAAA,GAAG,GAAGlB,IAAI,GAAG,CAAb;AACA;AA/HJ,KARqB,CAwInB;;;AAGFa,IAAAA,MAAM,CAAC6B,IAAP,CAAY,CAACb,SAAD,EAAY;AACxBZ,IAAAA,IADY,EACN;AACNlB,IAAAA,KAAK,GAAGiB,MAFI,EAEI;AAChBK,IAAAA,OAHY,EAGH;AACTD,IAAAA,SAJY,EAID;AACXrB,IAAAA,KALY,EAKL;AACPmB,IAAAA,GANY,CAMR;AANQ,KAAZ,EA3IqB,CAkJjB;;AAEJ,QAAIS,UAAJ,EAAgB;AACdX,MAAAA,MAAM,GAAGW,UAAT;AACAA,MAAAA,UAAU,GAAG,IAAb;AACD;;AAED5B,IAAAA,KAAK,GAAGmB,GAAR;AACD;;AAED,SAAOL,MAAP;AACD","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = tokenize;\nexports.FIELDS = void 0;\n\nvar t = _interopRequireWildcard(require(\"./tokenTypes\"));\n\nvar _unescapable, _wordDelimiters;\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);\nvar wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);\nvar hex = {};\nvar hexChars = \"0123456789abcdefABCDEF\";\n\nfor (var i = 0; i < hexChars.length; i++) {\n  hex[hexChars.charCodeAt(i)] = true;\n}\n/**\n *  Returns the last index of the bar css word\n * @param {string} css The string in which the word begins\n * @param {number} start The index into the string where word's first letter occurs\n */\n\n\nfunction consumeWord(css, start) {\n  var next = start;\n  var code;\n\n  do {\n    code = css.charCodeAt(next);\n\n    if (wordDelimiters[code]) {\n      return next - 1;\n    } else if (code === t.backslash) {\n      next = consumeEscape(css, next) + 1;\n    } else {\n      // All other characters are part of the word\n      next++;\n    }\n  } while (next < css.length);\n\n  return next - 1;\n}\n/**\n *  Returns the last index of the escape sequence\n * @param {string} css The string in which the sequence begins\n * @param {number} start The index into the string where escape character (`\\`) occurs.\n */\n\n\nfunction consumeEscape(css, start) {\n  var next = start;\n  var code = css.charCodeAt(next + 1);\n\n  if (unescapable[code]) {// just consume the escape char\n  } else if (hex[code]) {\n    var hexDigits = 0; // consume up to 6 hex chars\n\n    do {\n      next++;\n      hexDigits++;\n      code = css.charCodeAt(next + 1);\n    } while (hex[code] && hexDigits < 6); // if fewer than 6 hex chars, a trailing space ends the escape\n\n\n    if (hexDigits < 6 && code === t.space) {\n      next++;\n    }\n  } else {\n    // the next char is part of the current word\n    next++;\n  }\n\n  return next;\n}\n\nvar FIELDS = {\n  TYPE: 0,\n  START_LINE: 1,\n  START_COL: 2,\n  END_LINE: 3,\n  END_COL: 4,\n  START_POS: 5,\n  END_POS: 6\n};\nexports.FIELDS = FIELDS;\n\nfunction tokenize(input) {\n  var tokens = [];\n  var css = input.css.valueOf();\n  var _css = css,\n      length = _css.length;\n  var offset = -1;\n  var line = 1;\n  var start = 0;\n  var end = 0;\n  var code, content, endColumn, endLine, escaped, escapePos, last, lines, next, nextLine, nextOffset, quote, tokenType;\n\n  function unclosed(what, fix) {\n    if (input.safe) {\n      // fyi: this is never set to true.\n      css += fix;\n      next = css.length - 1;\n    } else {\n      throw input.error('Unclosed ' + what, line, start - offset, start);\n    }\n  }\n\n  while (start < length) {\n    code = css.charCodeAt(start);\n\n    if (code === t.newline) {\n      offset = start;\n      line += 1;\n    }\n\n    switch (code) {\n      case t.space:\n      case t.tab:\n      case t.newline:\n      case t.cr:\n      case t.feed:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n\n          if (code === t.newline) {\n            offset = next;\n            line += 1;\n          }\n        } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);\n\n        tokenType = t.space;\n        endLine = line;\n        endColumn = next - offset - 1;\n        end = next;\n        break;\n\n      case t.plus:\n      case t.greaterThan:\n      case t.tilde:\n      case t.pipe:\n        next = start;\n\n        do {\n          next += 1;\n          code = css.charCodeAt(next);\n        } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);\n\n        tokenType = t.combinator;\n        endLine = line;\n        endColumn = start - offset;\n        end = next;\n        break;\n      // Consume these characters as single tokens.\n\n      case t.asterisk:\n      case t.ampersand:\n      case t.bang:\n      case t.comma:\n      case t.equals:\n      case t.dollar:\n      case t.caret:\n      case t.openSquare:\n      case t.closeSquare:\n      case t.colon:\n      case t.semicolon:\n      case t.openParenthesis:\n      case t.closeParenthesis:\n        next = start;\n        tokenType = code;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      case t.singleQuote:\n      case t.doubleQuote:\n        quote = code === t.singleQuote ? \"'\" : '\"';\n        next = start;\n\n        do {\n          escaped = false;\n          next = css.indexOf(quote, next + 1);\n\n          if (next === -1) {\n            unclosed('quote', quote);\n          }\n\n          escapePos = next;\n\n          while (css.charCodeAt(escapePos - 1) === t.backslash) {\n            escapePos -= 1;\n            escaped = !escaped;\n          }\n        } while (escaped);\n\n        tokenType = t.str;\n        endLine = line;\n        endColumn = start - offset;\n        end = next + 1;\n        break;\n\n      default:\n        if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {\n          next = css.indexOf('*/', start + 2) + 1;\n\n          if (next === 0) {\n            unclosed('comment', '*/');\n          }\n\n          content = css.slice(start, next + 1);\n          lines = content.split('\\n');\n          last = lines.length - 1;\n\n          if (last > 0) {\n            nextLine = line + last;\n            nextOffset = next - lines[last].length;\n          } else {\n            nextLine = line;\n            nextOffset = offset;\n          }\n\n          tokenType = t.comment;\n          line = nextLine;\n          endLine = nextLine;\n          endColumn = next - nextOffset;\n        } else if (code === t.slash) {\n          next = start;\n          tokenType = code;\n          endLine = line;\n          endColumn = start - offset;\n          end = next + 1;\n        } else {\n          next = consumeWord(css, start);\n          tokenType = t.word;\n          endLine = line;\n          endColumn = next - offset;\n        }\n\n        end = next + 1;\n        break;\n    } // Ensure that the token structure remains consistent\n\n\n    tokens.push([tokenType, // [0] Token type\n    line, // [1] Starting line\n    start - offset, // [2] Starting column\n    endLine, // [3] Ending line\n    endColumn, // [4] Ending column\n    start, // [5] Start position / Source index\n    end // [6] End position\n    ]); // Reset offset for the next token\n\n    if (nextOffset) {\n      offset = nextOffset;\n      nextOffset = null;\n    }\n\n    start = end;\n  }\n\n  return tokens;\n}"]},"metadata":{},"sourceType":"script"}