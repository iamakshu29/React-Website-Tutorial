{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _root = _interopRequireDefault(require(\"./selectors/root\"));\n\nvar _selector = _interopRequireDefault(require(\"./selectors/selector\"));\n\nvar _className = _interopRequireDefault(require(\"./selectors/className\"));\n\nvar _comment = _interopRequireDefault(require(\"./selectors/comment\"));\n\nvar _id = _interopRequireDefault(require(\"./selectors/id\"));\n\nvar _tag = _interopRequireDefault(require(\"./selectors/tag\"));\n\nvar _string = _interopRequireDefault(require(\"./selectors/string\"));\n\nvar _pseudo = _interopRequireDefault(require(\"./selectors/pseudo\"));\n\nvar _attribute = _interopRequireWildcard(require(\"./selectors/attribute\"));\n\nvar _universal = _interopRequireDefault(require(\"./selectors/universal\"));\n\nvar _combinator = _interopRequireDefault(require(\"./selectors/combinator\"));\n\nvar _nesting = _interopRequireDefault(require(\"./selectors/nesting\"));\n\nvar _sortAscending = _interopRequireDefault(require(\"./sortAscending\"));\n\nvar _tokenize = _interopRequireWildcard(require(\"./tokenize\"));\n\nvar tokens = _interopRequireWildcard(require(\"./tokenTypes\"));\n\nvar types = _interopRequireWildcard(require(\"./selectors/types\"));\n\nvar _util = require(\"./util\");\n\nvar _WHITESPACE_TOKENS, _Object$assign;\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\nvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\n\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\n\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\n\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\n\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\n\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n\n  if (typeof value !== \"string\") {\n    return;\n  }\n\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n\n  return node;\n}\n\nfunction indexesOf(array, item) {\n  var i = -1;\n  var indexes = [];\n\n  while ((i = array.indexOf(item, i + 1)) !== -1) {\n    indexes.push(i);\n  }\n\n  return indexes;\n}\n\nfunction uniqs() {\n  var list = Array.prototype.concat.apply([], arguments);\n  return list.filter(function (item, i) {\n    return i === list.indexOf(item);\n  });\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize[\"default\"])({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root[\"default\"]({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto._errorGenerator = function _errorGenerator() {\n    var _this = this;\n\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n\n  _proto.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n\n          if (this.options.lossy) {\n            break;\n          }\n\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n\n            lastAdded = 'namespace';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n\n            break;\n          }\n\n        // Falls through\n\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n\n            node.attribute = (node.attribute || \"\") + content;\n\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n\n            lastAdded = 'attribute';\n          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n            var _unescaped = (0, _util.unesc)(content);\n\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n\n            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n\n              lastAdded = 'insensitive';\n\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value || node.value === '') {\n              lastAdded = 'value';\n              node.value += content;\n\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n              unescaped = _unescapeValue.unescaped,\n              quoteMark = _unescapeValue.quoteMark;\n\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        default:\n          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n\n      pos++;\n    }\n\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute[\"default\"](node));\n    this.position++;\n  }\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */\n  ;\n\n  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n\n        lastComment = new _comment[\"default\"]({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string[\"default\"]({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n\n    return nodes;\n  }\n  /**\n   * \n   * @param {*} nodes \n   */\n  ;\n\n  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n    var _this2 = this;\n\n    if (requiredSpace === void 0) {\n      requiredSpace = false;\n    }\n\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n\n  _proto.isNamedCombinator = function isNamedCombinator(position) {\n    if (position === void 0) {\n      position = this.position;\n    }\n\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n\n  _proto.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n\n      if (name !== nameRaw) {\n        raws.value = \"/\" + nameRaw + \"/\";\n      }\n\n      var node = new _combinator[\"default\"]({\n        value: \"/\" + name + \"/\",\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n\n  _proto.combinator = function combinator() {\n    var _this3 = this;\n\n    if (this.content() === '|') {\n      return this.namespace();\n    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n\n\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\n      if (nodes.length > 0) {\n        var last = this.current.last;\n\n        if (last) {\n          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n              space = _this$convertWhitespa.space,\n              rawSpace = _this$convertWhitespa.rawSpace;\n\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n\n      return;\n    }\n\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n\n    var node;\n\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator[\"default\"]({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n            _space = _this$convertWhitespa2.space,\n            _rawSpace = _this$convertWhitespa2.rawSpace;\n\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n          _space2 = _this$convertWhitespa3.space,\n          _rawSpace2 = _this$convertWhitespa3.rawSpace;\n\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n\n      node = new _combinator[\"default\"]({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n\n    return this.newNode(node);\n  };\n\n  _proto.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n\n    this.current._inferEndPosition();\n\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n\n  _proto.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n\n  _proto.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n\n  _proto.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.unexpected = function unexpected() {\n    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n  };\n\n  _proto.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n\n    var current = this.currToken;\n    this.newNode(new _nesting[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector[\"default\"]({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string[\"default\"]({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.pseudo = function pseudo() {\n    var _this4 = this;\n\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n\n        _this4.newNode(new _pseudo[\"default\"]({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.space = function space() {\n    var content = this.content(); // Handle space before and after the selector\n\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n      return node.type === 'comment';\n    })) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n\n  _proto.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    var current = this.currToken;\n    this.newNode(new _universal[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n\n  _proto.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n\n    var nextToken = this.nextToken;\n    var word = this.content();\n\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n\n      nextToken = this.nextToken;\n    }\n\n    var hasClass = indexesOf(word, '.').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    });\n    var hasId = indexesOf(word, '#').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    }); // Eliminate Sass interpolations from the list of id indexes\n\n    var interpolations = indexesOf(word, '#{');\n\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n\n    var indices = (0, _sortAscending[\"default\"])(uniqs([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n\n      var node;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className[\"default\"](unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id[\"default\"](unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag[\"default\"](tagOpts);\n      }\n\n      _this5.newNode(node, namespace); // Ensure that the namespace is used only once\n\n\n      namespace = null;\n    });\n    this.position++;\n  };\n\n  _proto.word = function word(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    return this.splitWord(namespace);\n  };\n\n  _proto.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n\n    this.current._inferEndPosition();\n\n    return this.root;\n  };\n\n  _proto.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n\n      case tokens.comment:\n        this.comment();\n        break;\n\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n\n        break;\n\n      case tokens.openSquare:\n        this.attribute();\n        break;\n\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n\n      case tokens.colon:\n        this.pseudo();\n        break;\n\n      case tokens.comma:\n        this.comma();\n        break;\n\n      case tokens.asterisk:\n        this.universal();\n        break;\n\n      case tokens.ampersand:\n        this.nesting();\n        break;\n\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n\n      case tokens.semicolon:\n        this.missingBackslash();\n\n      default:\n        this.unexpected();\n    }\n  }\n  /**\n   * Helpers\n   */\n  ;\n\n  _proto.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + \" or \" + last;\n    }\n\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n\n    if (!found) {\n      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n        index: index\n      });\n    }\n\n    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n      index: index\n    });\n  };\n\n  _proto.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n\n  _proto.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n\n  _proto.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n\n  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n\n  _proto.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n\n        namespace = true;\n      }\n\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n\n    return this.current.append(node);\n  };\n\n  _proto.content = function content(token) {\n    if (token === void 0) {\n      token = this.currToken;\n    }\n\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n\n\n  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = this.position + 1;\n    }\n\n    var searchPosition = startPosition;\n\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n\n    return -1;\n  };\n\n  _createClass(Parser, [{\n    key: \"currToken\",\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: \"nextToken\",\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports[\"default\"] = Parser;\nmodule.exports = exports.default;","map":{"version":3,"sources":["C:/Users/Akshat Verma/Desktop/Practice/react/react_tut/node_modules/postcss-selector-parser/dist/parser.js"],"names":["exports","__esModule","_root","_interopRequireDefault","require","_selector","_className","_comment","_id","_tag","_string","_pseudo","_attribute","_interopRequireWildcard","_universal","_combinator","_nesting","_sortAscending","_tokenize","tokens","types","_util","_WHITESPACE_TOKENS","_Object$assign","_getRequireWildcardCache","WeakMap","cache","obj","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","_createClass","Constructor","protoProps","staticProps","WHITESPACE_TOKENS","space","cr","feed","newline","tab","WHITESPACE_EQUIV_TOKENS","assign","comment","tokenStart","token","line","FIELDS","START_LINE","column","START_COL","tokenEnd","END_LINE","END_COL","getSource","startLine","startColumn","endLine","endColumn","start","end","getTokenSource","getTokenSourceSpan","startToken","endToken","undefined","unescapeProp","node","prop","value","indexOf","ensureObject","unesc","raws","indexesOf","array","item","indexes","push","uniqs","list","Array","concat","apply","arguments","filter","Parser","rule","options","lossy","safe","position","css","selector","error","_errorGenerator","rootSource","root","source","errorGenerator","append","current","loop","_proto","_this","message","errorOptions","Error","attribute","attr","startingToken","currToken","TYPE","closeSquare","expected","START_POS","len","sourceIndex","word","pos","spaceBefore","commentBefore","lastAdded","spaceAfterMeaningfulToken","content","next","prevContent","spaces","after","existingComment","getProp","asterisk","equals","operator","namespace","before","rawValue","dollar","oldRawValue","caret","combinator","_rawValue","_unescaped","_oldRawValue","oldValue","quoteMark","insensitive","insensitiveFlag","str","index","_unescapeValue","unescapeValue","unescaped","lastComment","rawLastComment","lastValue","rawLastValue","newNode","parseWhitespaceEquivalentTokens","stopPosition","startPosition","nodes","firstToken","lastToken","convertWhitespaceNodesToSpace","requiredSpace","_this2","rawSpace","forEach","n","lossySpace","rawSpaceBefore","rawSpaceAfter","result","isNamedCombinator","slash","namedCombinator","nameRaw","name","toLowerCase","unexpected","_this3","nextSigTokenPos","locateNextMeaningfulToken","comma","last","_this$convertWhitespa","spaceOrDescendantSelectorNodes","_this$convertWhitespa2","_space","_rawSpace","_this$convertWhitespa3","_space2","_rawSpace2","endsWith","slice","startsWith","optionalSpace","trailingComma","_inferEndPosition","parent","opts","missingBackslash","missingParenthesis","missingSquareBracket","prevToken","nextToken","universal","nesting","nextContent","parentheses","unbalanced","type","PSEUDO","openParenthesis","closeParenthesis","parse","parenStart","parenValue","parenEnd","parseParenthesisToken","appendToPropertyAndEscape","pseudo","_this4","pseudoStr","colon","splitWord","first","every","string","firstCallback","_this5","lastIndexOf","hasClass","hasId","interpolations","hashIndex","indices","ind","classNameOpts","idOpts","tagOpts","throwOnParenthesis","openSquare","ampersand","semicolon","description","found","isArray","pop","join","an","test","required","END_POS","searchPosition","module","default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _root = _interopRequireDefault(require(\"./selectors/root\"));\n\nvar _selector = _interopRequireDefault(require(\"./selectors/selector\"));\n\nvar _className = _interopRequireDefault(require(\"./selectors/className\"));\n\nvar _comment = _interopRequireDefault(require(\"./selectors/comment\"));\n\nvar _id = _interopRequireDefault(require(\"./selectors/id\"));\n\nvar _tag = _interopRequireDefault(require(\"./selectors/tag\"));\n\nvar _string = _interopRequireDefault(require(\"./selectors/string\"));\n\nvar _pseudo = _interopRequireDefault(require(\"./selectors/pseudo\"));\n\nvar _attribute = _interopRequireWildcard(require(\"./selectors/attribute\"));\n\nvar _universal = _interopRequireDefault(require(\"./selectors/universal\"));\n\nvar _combinator = _interopRequireDefault(require(\"./selectors/combinator\"));\n\nvar _nesting = _interopRequireDefault(require(\"./selectors/nesting\"));\n\nvar _sortAscending = _interopRequireDefault(require(\"./sortAscending\"));\n\nvar _tokenize = _interopRequireWildcard(require(\"./tokenize\"));\n\nvar tokens = _interopRequireWildcard(require(\"./tokenTypes\"));\n\nvar types = _interopRequireWildcard(require(\"./selectors/types\"));\n\nvar _util = require(\"./util\");\n\nvar _WHITESPACE_TOKENS, _Object$assign;\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);\nvar WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));\n\nfunction tokenStart(token) {\n  return {\n    line: token[_tokenize.FIELDS.START_LINE],\n    column: token[_tokenize.FIELDS.START_COL]\n  };\n}\n\nfunction tokenEnd(token) {\n  return {\n    line: token[_tokenize.FIELDS.END_LINE],\n    column: token[_tokenize.FIELDS.END_COL]\n  };\n}\n\nfunction getSource(startLine, startColumn, endLine, endColumn) {\n  return {\n    start: {\n      line: startLine,\n      column: startColumn\n    },\n    end: {\n      line: endLine,\n      column: endColumn\n    }\n  };\n}\n\nfunction getTokenSource(token) {\n  return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);\n}\n\nfunction getTokenSourceSpan(startToken, endToken) {\n  if (!startToken) {\n    return undefined;\n  }\n\n  return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);\n}\n\nfunction unescapeProp(node, prop) {\n  var value = node[prop];\n\n  if (typeof value !== \"string\") {\n    return;\n  }\n\n  if (value.indexOf(\"\\\\\") !== -1) {\n    (0, _util.ensureObject)(node, 'raws');\n    node[prop] = (0, _util.unesc)(value);\n\n    if (node.raws[prop] === undefined) {\n      node.raws[prop] = value;\n    }\n  }\n\n  return node;\n}\n\nfunction indexesOf(array, item) {\n  var i = -1;\n  var indexes = [];\n\n  while ((i = array.indexOf(item, i + 1)) !== -1) {\n    indexes.push(i);\n  }\n\n  return indexes;\n}\n\nfunction uniqs() {\n  var list = Array.prototype.concat.apply([], arguments);\n  return list.filter(function (item, i) {\n    return i === list.indexOf(item);\n  });\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(rule, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.rule = rule;\n    this.options = Object.assign({\n      lossy: false,\n      safe: false\n    }, options);\n    this.position = 0;\n    this.css = typeof this.rule === 'string' ? this.rule : this.rule.selector;\n    this.tokens = (0, _tokenize[\"default\"])({\n      css: this.css,\n      error: this._errorGenerator(),\n      safe: this.options.safe\n    });\n    var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);\n    this.root = new _root[\"default\"]({\n      source: rootSource\n    });\n    this.root.errorGenerator = this._errorGenerator();\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: {\n          line: 1,\n          column: 1\n        }\n      }\n    });\n    this.root.append(selector);\n    this.current = selector;\n    this.loop();\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto._errorGenerator = function _errorGenerator() {\n    var _this = this;\n\n    return function (message, errorOptions) {\n      if (typeof _this.rule === 'string') {\n        return new Error(message);\n      }\n\n      return _this.rule.error(message, errorOptions);\n    };\n  };\n\n  _proto.attribute = function attribute() {\n    var attr = [];\n    var startingToken = this.currToken;\n    this.position++;\n\n    while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      attr.push(this.currToken);\n      this.position++;\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {\n      return this.expected('closing square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n\n    var len = attr.length;\n    var node = {\n      source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),\n      sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n    };\n\n    if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {\n      return this.expected('attribute', attr[0][_tokenize.FIELDS.START_POS]);\n    }\n\n    var pos = 0;\n    var spaceBefore = '';\n    var commentBefore = '';\n    var lastAdded = null;\n    var spaceAfterMeaningfulToken = false;\n\n    while (pos < len) {\n      var token = attr[pos];\n      var content = this.content(token);\n      var next = attr[pos + 1];\n\n      switch (token[_tokenize.FIELDS.TYPE]) {\n        case tokens.space:\n          // if (\n          //     len === 1 ||\n          //     pos === 0 && this.content(next) === '|'\n          // ) {\n          //     return this.expected('attribute', token[TOKEN.START_POS], content);\n          // }\n          spaceAfterMeaningfulToken = true;\n\n          if (this.options.lossy) {\n            break;\n          }\n\n          if (lastAdded) {\n            (0, _util.ensureObject)(node, 'spaces', lastAdded);\n            var prevContent = node.spaces[lastAdded].after || '';\n            node.spaces[lastAdded].after = prevContent + content;\n            var existingComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || null;\n\n            if (existingComment) {\n              node.raws.spaces[lastAdded].after = existingComment + content;\n            }\n          } else {\n            spaceBefore = spaceBefore + content;\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        case tokens.asterisk:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if ((!node.namespace || lastAdded === \"namespace\" && !spaceAfterMeaningfulToken) && next) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = spaceBefore;\n              commentBefore = '';\n            }\n\n            node.namespace = (node.namespace || \"\") + content;\n            var rawValue = (0, _util.getProp)(node, 'raws', 'namespace') || null;\n\n            if (rawValue) {\n              node.raws.namespace += content;\n            }\n\n            lastAdded = 'namespace';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.dollar:\n          if (lastAdded === \"value\") {\n            var oldRawValue = (0, _util.getProp)(node, 'raws', 'value');\n            node.value += \"$\";\n\n            if (oldRawValue) {\n              node.raws.value = oldRawValue + \"$\";\n            }\n\n            break;\n          }\n\n        // Falls through\n\n        case tokens.caret:\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.combinator:\n          if (content === '~' && next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          }\n\n          if (content !== '|') {\n            spaceAfterMeaningfulToken = false;\n            break;\n          }\n\n          if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {\n            node.operator = content;\n            lastAdded = 'operator';\n          } else if (!node.namespace && !node.attribute) {\n            node.namespace = true;\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.word:\n          if (next && this.content(next) === '|' && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.\n          !node.operator && !node.namespace) {\n            node.namespace = content;\n            lastAdded = 'namespace';\n          } else if (!node.attribute || lastAdded === \"attribute\" && !spaceAfterMeaningfulToken) {\n            if (spaceBefore) {\n              (0, _util.ensureObject)(node, 'spaces', 'attribute');\n              node.spaces.attribute.before = spaceBefore;\n              spaceBefore = '';\n            }\n\n            if (commentBefore) {\n              (0, _util.ensureObject)(node, 'raws', 'spaces', 'attribute');\n              node.raws.spaces.attribute.before = commentBefore;\n              commentBefore = '';\n            }\n\n            node.attribute = (node.attribute || \"\") + content;\n\n            var _rawValue = (0, _util.getProp)(node, 'raws', 'attribute') || null;\n\n            if (_rawValue) {\n              node.raws.attribute += content;\n            }\n\n            lastAdded = 'attribute';\n          } else if (!node.value && node.value !== \"\" || lastAdded === \"value\" && !spaceAfterMeaningfulToken) {\n            var _unescaped = (0, _util.unesc)(content);\n\n            var _oldRawValue = (0, _util.getProp)(node, 'raws', 'value') || '';\n\n            var oldValue = node.value || '';\n            node.value = oldValue + _unescaped;\n            node.quoteMark = null;\n\n            if (_unescaped !== content || _oldRawValue) {\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws.value = (_oldRawValue || oldValue) + content;\n            }\n\n            lastAdded = 'value';\n          } else {\n            var insensitive = content === 'i' || content === \"I\";\n\n            if ((node.value || node.value === '') && (node.quoteMark || spaceAfterMeaningfulToken)) {\n              node.insensitive = insensitive;\n\n              if (!insensitive || content === \"I\") {\n                (0, _util.ensureObject)(node, 'raws');\n                node.raws.insensitiveFlag = content;\n              }\n\n              lastAdded = 'insensitive';\n\n              if (spaceBefore) {\n                (0, _util.ensureObject)(node, 'spaces', 'insensitive');\n                node.spaces.insensitive.before = spaceBefore;\n                spaceBefore = '';\n              }\n\n              if (commentBefore) {\n                (0, _util.ensureObject)(node, 'raws', 'spaces', 'insensitive');\n                node.raws.spaces.insensitive.before = commentBefore;\n                commentBefore = '';\n              }\n            } else if (node.value || node.value === '') {\n              lastAdded = 'value';\n              node.value += content;\n\n              if (node.raws.value) {\n                node.raws.value += content;\n              }\n            }\n          }\n\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.str:\n          if (!node.attribute || !node.operator) {\n            return this.error(\"Expected an attribute followed by an operator preceding the string.\", {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          var _unescapeValue = (0, _attribute.unescapeValue)(content),\n              unescaped = _unescapeValue.unescaped,\n              quoteMark = _unescapeValue.quoteMark;\n\n          node.value = unescaped;\n          node.quoteMark = quoteMark;\n          lastAdded = 'value';\n          (0, _util.ensureObject)(node, 'raws');\n          node.raws.value = content;\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.equals:\n          if (!node.attribute) {\n            return this.expected('attribute', token[_tokenize.FIELDS.START_POS], content);\n          }\n\n          if (node.value) {\n            return this.error('Unexpected \"=\" found; an operator was already defined.', {\n              index: token[_tokenize.FIELDS.START_POS]\n            });\n          }\n\n          node.operator = node.operator ? node.operator + content : content;\n          lastAdded = 'operator';\n          spaceAfterMeaningfulToken = false;\n          break;\n\n        case tokens.comment:\n          if (lastAdded) {\n            if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === 'insensitive') {\n              var lastComment = (0, _util.getProp)(node, 'spaces', lastAdded, 'after') || '';\n              var rawLastComment = (0, _util.getProp)(node, 'raws', 'spaces', lastAdded, 'after') || lastComment;\n              (0, _util.ensureObject)(node, 'raws', 'spaces', lastAdded);\n              node.raws.spaces[lastAdded].after = rawLastComment + content;\n            } else {\n              var lastValue = node[lastAdded] || '';\n              var rawLastValue = (0, _util.getProp)(node, 'raws', lastAdded) || lastValue;\n              (0, _util.ensureObject)(node, 'raws');\n              node.raws[lastAdded] = rawLastValue + content;\n            }\n          } else {\n            commentBefore = commentBefore + content;\n          }\n\n          break;\n\n        default:\n          return this.error(\"Unexpected \\\"\" + content + \"\\\" found.\", {\n            index: token[_tokenize.FIELDS.START_POS]\n          });\n      }\n\n      pos++;\n    }\n\n    unescapeProp(node, \"attribute\");\n    unescapeProp(node, \"namespace\");\n    this.newNode(new _attribute[\"default\"](node));\n    this.position++;\n  }\n  /**\n   * return a node containing meaningless garbage up to (but not including) the specified token position.\n   * if the token position is negative, all remaining tokens are consumed.\n   *\n   * This returns an array containing a single string node if all whitespace,\n   * otherwise an array of comment nodes with space before and after.\n   *\n   * These tokens are not added to the current selector, the caller can add them or use them to amend\n   * a previous node's space metadata.\n   *\n   * In lossy mode, this returns only comments.\n   */\n  ;\n\n  _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {\n    if (stopPosition < 0) {\n      stopPosition = this.tokens.length;\n    }\n\n    var startPosition = this.position;\n    var nodes = [];\n    var space = \"\";\n    var lastComment = undefined;\n\n    do {\n      if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {\n        if (!this.options.lossy) {\n          space += this.content();\n        }\n      } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {\n        var spaces = {};\n\n        if (space) {\n          spaces.before = space;\n          space = \"\";\n        }\n\n        lastComment = new _comment[\"default\"]({\n          value: this.content(),\n          source: getTokenSource(this.currToken),\n          sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n          spaces: spaces\n        });\n        nodes.push(lastComment);\n      }\n    } while (++this.position < stopPosition);\n\n    if (space) {\n      if (lastComment) {\n        lastComment.spaces.after = space;\n      } else if (!this.options.lossy) {\n        var firstToken = this.tokens[startPosition];\n        var lastToken = this.tokens[this.position - 1];\n        nodes.push(new _string[\"default\"]({\n          value: '',\n          source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),\n          sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n          spaces: {\n            before: space,\n            after: ''\n          }\n        }));\n      }\n    }\n\n    return nodes;\n  }\n  /**\n   * \n   * @param {*} nodes \n   */\n  ;\n\n  _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {\n    var _this2 = this;\n\n    if (requiredSpace === void 0) {\n      requiredSpace = false;\n    }\n\n    var space = \"\";\n    var rawSpace = \"\";\n    nodes.forEach(function (n) {\n      var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);\n\n      var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);\n\n      space += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);\n      rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);\n    });\n\n    if (rawSpace === space) {\n      rawSpace = undefined;\n    }\n\n    var result = {\n      space: space,\n      rawSpace: rawSpace\n    };\n    return result;\n  };\n\n  _proto.isNamedCombinator = function isNamedCombinator(position) {\n    if (position === void 0) {\n      position = this.position;\n    }\n\n    return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;\n  };\n\n  _proto.namedCombinator = function namedCombinator() {\n    if (this.isNamedCombinator()) {\n      var nameRaw = this.content(this.tokens[this.position + 1]);\n      var name = (0, _util.unesc)(nameRaw).toLowerCase();\n      var raws = {};\n\n      if (name !== nameRaw) {\n        raws.value = \"/\" + nameRaw + \"/\";\n      }\n\n      var node = new _combinator[\"default\"]({\n        value: \"/\" + name + \"/\",\n        source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],\n        raws: raws\n      });\n      this.position = this.position + 3;\n      return node;\n    } else {\n      this.unexpected();\n    }\n  };\n\n  _proto.combinator = function combinator() {\n    var _this3 = this;\n\n    if (this.content() === '|') {\n      return this.namespace();\n    } // We need to decide between a space that's a descendant combinator and meaningless whitespace at the end of a selector.\n\n\n    var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);\n\n    if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {\n      var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n\n      if (nodes.length > 0) {\n        var last = this.current.last;\n\n        if (last) {\n          var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes),\n              space = _this$convertWhitespa.space,\n              rawSpace = _this$convertWhitespa.rawSpace;\n\n          if (rawSpace !== undefined) {\n            last.rawSpaceAfter += rawSpace;\n          }\n\n          last.spaces.after += space;\n        } else {\n          nodes.forEach(function (n) {\n            return _this3.newNode(n);\n          });\n        }\n      }\n\n      return;\n    }\n\n    var firstToken = this.currToken;\n    var spaceOrDescendantSelectorNodes = undefined;\n\n    if (nextSigTokenPos > this.position) {\n      spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);\n    }\n\n    var node;\n\n    if (this.isNamedCombinator()) {\n      node = this.namedCombinator();\n    } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {\n      node = new _combinator[\"default\"]({\n        value: this.content(),\n        source: getTokenSource(this.currToken),\n        sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]\n      });\n      this.position++;\n    } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {// pass\n    } else if (!spaceOrDescendantSelectorNodes) {\n      this.unexpected();\n    }\n\n    if (node) {\n      if (spaceOrDescendantSelectorNodes) {\n        var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes),\n            _space = _this$convertWhitespa2.space,\n            _rawSpace = _this$convertWhitespa2.rawSpace;\n\n        node.spaces.before = _space;\n        node.rawSpaceBefore = _rawSpace;\n      }\n    } else {\n      // descendant combinator\n      var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true),\n          _space2 = _this$convertWhitespa3.space,\n          _rawSpace2 = _this$convertWhitespa3.rawSpace;\n\n      if (!_rawSpace2) {\n        _rawSpace2 = _space2;\n      }\n\n      var spaces = {};\n      var raws = {\n        spaces: {}\n      };\n\n      if (_space2.endsWith(' ') && _rawSpace2.endsWith(' ')) {\n        spaces.before = _space2.slice(0, _space2.length - 1);\n        raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);\n      } else if (_space2.startsWith(' ') && _rawSpace2.startsWith(' ')) {\n        spaces.after = _space2.slice(1);\n        raws.spaces.after = _rawSpace2.slice(1);\n      } else {\n        raws.value = _rawSpace2;\n      }\n\n      node = new _combinator[\"default\"]({\n        value: ' ',\n        source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),\n        sourceIndex: firstToken[_tokenize.FIELDS.START_POS],\n        spaces: spaces,\n        raws: raws\n      });\n    }\n\n    if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {\n      node.spaces.after = this.optionalSpace(this.content());\n      this.position++;\n    }\n\n    return this.newNode(node);\n  };\n\n  _proto.comma = function comma() {\n    if (this.position === this.tokens.length - 1) {\n      this.root.trailingComma = true;\n      this.position++;\n      return;\n    }\n\n    this.current._inferEndPosition();\n\n    var selector = new _selector[\"default\"]({\n      source: {\n        start: tokenStart(this.tokens[this.position + 1])\n      }\n    });\n    this.current.parent.append(selector);\n    this.current = selector;\n    this.position++;\n  };\n\n  _proto.comment = function comment() {\n    var current = this.currToken;\n    this.newNode(new _comment[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.error = function error(message, opts) {\n    throw this.root.error(message, opts);\n  };\n\n  _proto.missingBackslash = function missingBackslash() {\n    return this.error('Expected a backslash preceding the semicolon.', {\n      index: this.currToken[_tokenize.FIELDS.START_POS]\n    });\n  };\n\n  _proto.missingParenthesis = function missingParenthesis() {\n    return this.expected('opening parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.missingSquareBracket = function missingSquareBracket() {\n    return this.expected('opening square bracket', this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.unexpected = function unexpected() {\n    return this.error(\"Unexpected '\" + this.content() + \"'. Escaping special characters with \\\\ may help.\", this.currToken[_tokenize.FIELDS.START_POS]);\n  };\n\n  _proto.namespace = function namespace() {\n    var before = this.prevToken && this.content(this.prevToken) || true;\n\n    if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.position++;\n      return this.word(before);\n    } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {\n      this.position++;\n      return this.universal(before);\n    }\n  };\n\n  _proto.nesting = function nesting() {\n    if (this.nextToken) {\n      var nextContent = this.content(this.nextToken);\n\n      if (nextContent === \"|\") {\n        this.position++;\n        return;\n      }\n    }\n\n    var current = this.currToken;\n    this.newNode(new _nesting[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.parentheses = function parentheses() {\n    var last = this.current.last;\n    var unbalanced = 1;\n    this.position++;\n\n    if (last && last.type === types.PSEUDO) {\n      var selector = new _selector[\"default\"]({\n        source: {\n          start: tokenStart(this.tokens[this.position - 1])\n        }\n      });\n      var cache = this.current;\n      last.append(selector);\n      this.current = selector;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        if (unbalanced) {\n          this.parse();\n        } else {\n          this.current.source.end = tokenEnd(this.currToken);\n          this.current.parent.source.end = tokenEnd(this.currToken);\n          this.position++;\n        }\n      }\n\n      this.current = cache;\n    } else {\n      // I think this case should be an error. It's used to implement a basic parse of media queries\n      // but I don't think it's a good idea.\n      var parenStart = this.currToken;\n      var parenValue = \"(\";\n      var parenEnd;\n\n      while (this.position < this.tokens.length && unbalanced) {\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          unbalanced++;\n        }\n\n        if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n          unbalanced--;\n        }\n\n        parenEnd = this.currToken;\n        parenValue += this.parseParenthesisToken(this.currToken);\n        this.position++;\n      }\n\n      if (last) {\n        last.appendToPropertyAndEscape(\"value\", parenValue, parenValue);\n      } else {\n        this.newNode(new _string[\"default\"]({\n          value: parenValue,\n          source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),\n          sourceIndex: parenStart[_tokenize.FIELDS.START_POS]\n        }));\n      }\n    }\n\n    if (unbalanced) {\n      return this.expected('closing parenthesis', this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.pseudo = function pseudo() {\n    var _this4 = this;\n\n    var pseudoStr = '';\n    var startingToken = this.currToken;\n\n    while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {\n      pseudoStr += this.content();\n      this.position++;\n    }\n\n    if (!this.currToken) {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.position - 1);\n    }\n\n    if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {\n      this.splitWord(false, function (first, length) {\n        pseudoStr += first;\n\n        _this4.newNode(new _pseudo[\"default\"]({\n          value: pseudoStr,\n          source: getTokenSourceSpan(startingToken, _this4.currToken),\n          sourceIndex: startingToken[_tokenize.FIELDS.START_POS]\n        }));\n\n        if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {\n          _this4.error('Misplaced parenthesis.', {\n            index: _this4.nextToken[_tokenize.FIELDS.START_POS]\n          });\n        }\n      });\n    } else {\n      return this.expected(['pseudo-class', 'pseudo-element'], this.currToken[_tokenize.FIELDS.START_POS]);\n    }\n  };\n\n  _proto.space = function space() {\n    var content = this.content(); // Handle space before and after the selector\n\n    if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function (node) {\n      return node.type === 'comment';\n    })) {\n      this.spaces = this.optionalSpace(content);\n      this.position++;\n    } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {\n      this.current.last.spaces.after = this.optionalSpace(content);\n      this.position++;\n    } else {\n      this.combinator();\n    }\n  };\n\n  _proto.string = function string() {\n    var current = this.currToken;\n    this.newNode(new _string[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }));\n    this.position++;\n  };\n\n  _proto.universal = function universal(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    var current = this.currToken;\n    this.newNode(new _universal[\"default\"]({\n      value: this.content(),\n      source: getTokenSource(current),\n      sourceIndex: current[_tokenize.FIELDS.START_POS]\n    }), namespace);\n    this.position++;\n  };\n\n  _proto.splitWord = function splitWord(namespace, firstCallback) {\n    var _this5 = this;\n\n    var nextToken = this.nextToken;\n    var word = this.content();\n\n    while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {\n      this.position++;\n      var current = this.content();\n      word += current;\n\n      if (current.lastIndexOf('\\\\') === current.length - 1) {\n        var next = this.nextToken;\n\n        if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {\n          word += this.requiredSpace(this.content(next));\n          this.position++;\n        }\n      }\n\n      nextToken = this.nextToken;\n    }\n\n    var hasClass = indexesOf(word, '.').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    });\n    var hasId = indexesOf(word, '#').filter(function (i) {\n      return word[i - 1] !== '\\\\';\n    }); // Eliminate Sass interpolations from the list of id indexes\n\n    var interpolations = indexesOf(word, '#{');\n\n    if (interpolations.length) {\n      hasId = hasId.filter(function (hashIndex) {\n        return !~interpolations.indexOf(hashIndex);\n      });\n    }\n\n    var indices = (0, _sortAscending[\"default\"])(uniqs([0].concat(hasClass, hasId)));\n    indices.forEach(function (ind, i) {\n      var index = indices[i + 1] || word.length;\n      var value = word.slice(ind, index);\n\n      if (i === 0 && firstCallback) {\n        return firstCallback.call(_this5, value, indices.length);\n      }\n\n      var node;\n      var current = _this5.currToken;\n      var sourceIndex = current[_tokenize.FIELDS.START_POS] + indices[i];\n      var source = getSource(current[1], current[2] + ind, current[3], current[2] + (index - 1));\n\n      if (~hasClass.indexOf(ind)) {\n        var classNameOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _className[\"default\"](unescapeProp(classNameOpts, \"value\"));\n      } else if (~hasId.indexOf(ind)) {\n        var idOpts = {\n          value: value.slice(1),\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        node = new _id[\"default\"](unescapeProp(idOpts, \"value\"));\n      } else {\n        var tagOpts = {\n          value: value,\n          source: source,\n          sourceIndex: sourceIndex\n        };\n        unescapeProp(tagOpts, \"value\");\n        node = new _tag[\"default\"](tagOpts);\n      }\n\n      _this5.newNode(node, namespace); // Ensure that the namespace is used only once\n\n\n      namespace = null;\n    });\n    this.position++;\n  };\n\n  _proto.word = function word(namespace) {\n    var nextToken = this.nextToken;\n\n    if (nextToken && this.content(nextToken) === '|') {\n      this.position++;\n      return this.namespace();\n    }\n\n    return this.splitWord(namespace);\n  };\n\n  _proto.loop = function loop() {\n    while (this.position < this.tokens.length) {\n      this.parse(true);\n    }\n\n    this.current._inferEndPosition();\n\n    return this.root;\n  };\n\n  _proto.parse = function parse(throwOnParenthesis) {\n    switch (this.currToken[_tokenize.FIELDS.TYPE]) {\n      case tokens.space:\n        this.space();\n        break;\n\n      case tokens.comment:\n        this.comment();\n        break;\n\n      case tokens.openParenthesis:\n        this.parentheses();\n        break;\n\n      case tokens.closeParenthesis:\n        if (throwOnParenthesis) {\n          this.missingParenthesis();\n        }\n\n        break;\n\n      case tokens.openSquare:\n        this.attribute();\n        break;\n\n      case tokens.dollar:\n      case tokens.caret:\n      case tokens.equals:\n      case tokens.word:\n        this.word();\n        break;\n\n      case tokens.colon:\n        this.pseudo();\n        break;\n\n      case tokens.comma:\n        this.comma();\n        break;\n\n      case tokens.asterisk:\n        this.universal();\n        break;\n\n      case tokens.ampersand:\n        this.nesting();\n        break;\n\n      case tokens.slash:\n      case tokens.combinator:\n        this.combinator();\n        break;\n\n      case tokens.str:\n        this.string();\n        break;\n      // These cases throw; no break needed.\n\n      case tokens.closeSquare:\n        this.missingSquareBracket();\n\n      case tokens.semicolon:\n        this.missingBackslash();\n\n      default:\n        this.unexpected();\n    }\n  }\n  /**\n   * Helpers\n   */\n  ;\n\n  _proto.expected = function expected(description, index, found) {\n    if (Array.isArray(description)) {\n      var last = description.pop();\n      description = description.join(', ') + \" or \" + last;\n    }\n\n    var an = /^[aeiou]/.test(description[0]) ? 'an' : 'a';\n\n    if (!found) {\n      return this.error(\"Expected \" + an + \" \" + description + \".\", {\n        index: index\n      });\n    }\n\n    return this.error(\"Expected \" + an + \" \" + description + \", found \\\"\" + found + \"\\\" instead.\", {\n      index: index\n    });\n  };\n\n  _proto.requiredSpace = function requiredSpace(space) {\n    return this.options.lossy ? ' ' : space;\n  };\n\n  _proto.optionalSpace = function optionalSpace(space) {\n    return this.options.lossy ? '' : space;\n  };\n\n  _proto.lossySpace = function lossySpace(space, required) {\n    if (this.options.lossy) {\n      return required ? ' ' : '';\n    } else {\n      return space;\n    }\n  };\n\n  _proto.parseParenthesisToken = function parseParenthesisToken(token) {\n    var content = this.content(token);\n\n    if (token[_tokenize.FIELDS.TYPE] === tokens.space) {\n      return this.requiredSpace(content);\n    } else {\n      return content;\n    }\n  };\n\n  _proto.newNode = function newNode(node, namespace) {\n    if (namespace) {\n      if (/^ +$/.test(namespace)) {\n        if (!this.options.lossy) {\n          this.spaces = (this.spaces || '') + namespace;\n        }\n\n        namespace = true;\n      }\n\n      node.namespace = namespace;\n      unescapeProp(node, \"namespace\");\n    }\n\n    if (this.spaces) {\n      node.spaces.before = this.spaces;\n      this.spaces = '';\n    }\n\n    return this.current.append(node);\n  };\n\n  _proto.content = function content(token) {\n    if (token === void 0) {\n      token = this.currToken;\n    }\n\n    return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);\n  };\n\n  /**\n   * returns the index of the next non-whitespace, non-comment token.\n   * returns -1 if no meaningful token is found.\n   */\n  _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {\n    if (startPosition === void 0) {\n      startPosition = this.position + 1;\n    }\n\n    var searchPosition = startPosition;\n\n    while (searchPosition < this.tokens.length) {\n      if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {\n        searchPosition++;\n        continue;\n      } else {\n        return searchPosition;\n      }\n    }\n\n    return -1;\n  };\n\n  _createClass(Parser, [{\n    key: \"currToken\",\n    get: function get() {\n      return this.tokens[this.position];\n    }\n  }, {\n    key: \"nextToken\",\n    get: function get() {\n      return this.tokens[this.position + 1];\n    }\n  }, {\n    key: \"prevToken\",\n    get: function get() {\n      return this.tokens[this.position - 1];\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports[\"default\"] = Parser;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}